! ###################################################################
! Copyright (c) 2014-2023 Marc De Graef/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this
!        list of conditions and the following disclaimer in the documentation and/or
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names
!        of its contributors may be used to endorse or promote products derived from
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################

!---------------------------
! THIS FILE IS AUTOMATICALLY GENERATED DURING CMAKE TIME. THE ORIGINAL FILE
! LOCATED AT @CTEMSoftLib_SOURCE_DIR@/mod_EMsoft.in.f90
! YOU NEED TO MAKE CHANGES TO THAT FILE. ANY CHANGES MADE TO THIS FILE WILL
! BE OVERWRITTEN THE NEXT TIME CMAKE IS EXECUTED.
!---------------------------

module mod_EMsoft
  !! author: MDG
  !! version: 1.0
  !! date: 12/30/19
  !!
  !! This class provides access to all the configuration parameters from the config file,
  !! as well as any command line or environment parameters that are relevant.  Upon starting any
  !! EMsoft program, the following lines should be included:
  !!
  !!   use mod_global
  !!
  !!   use mod_EMsoft
  !!
  !!   character(fnlen)        :: progname = 'this is the program name'
  !!
  !!   character(fnlen)        :: progdesc = 'and this is the descriptor'
  !!
  !!   type(EMsoft_T)     :: EMsoft
  !!
  !!   ! this is a call to the constructor routine
  !!
  !!   EMsoft = EMsoft_T(progname, progdesc[,makeconfig][,showconfig])
  !!
  !! This will print the usual start up message with copyright, build date, version, etc. info.
  !! It will also initialize all the configuration parameters; these are then available to the
  !! calling program by means of the getConfigParameter method. The setConfigParameter method can
  !! be used to explicitly override any of the config parameters in this class.
  !!
  !! The optional arguments to the constructor can be used to create the EMsoftConfig.json file
  !! (using makeconfig=.TRUE.), or to simply print out all the configuration parameters (using
  !! showconfig=.TRUE.).
  !!
  !! Finally, the method generateFilePath can be used to complete any given file path; in the old
  !! f90 code this was done in three consecutive lines that were always basically the same, and here
  !! we provide a method to simply return the file name completed with the full path.
  !!
  !! This class also deals with the command line arguments and the generation of
  !! template files (this used to be part of the files.f90 module).


use mod_kinds
use mod_global
use stringconstants
use, intrinsic :: ISO_C_BINDING
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit

IMPLICIT NONE

private

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

  type, public   ::  EMsoft_T
    !! EMsoft Class definition
    private
     character(fnlen)  :: EMsoftpathname
      !! path to the top of the EMsoft distribution
     character(fnlen)  :: EMXtalFolderpathname
      !! path to the location of the .xtal file folder
     character(fnlen)  :: EMdatapathname
      !! path to the location of all data files
     character(fnlen)  :: EMtmppathname
      !! path to a temporary folder
     character(fnlen)  :: EMsoftLibraryLocation
      !! location of the main dylib/dll file, used only for IDL applications
     character(fnlen)  :: UserName
      !! user name
     character(fnlen)  :: UserLocation
      !! user location
     character(fnlen)  :: UserEmail
      !! user email (used for messaging)
     character(5)      :: EMNotify
      !! is messaging enabled? (Email or Slack)
     character(3)      :: EMDevelop
      !! is this a development installation (Yes/No)
     character(3)      :: EMRelease
      !! is this a release version (Yes/No)
! other configuration parameters that may be needed in various programs but are not in the EMsoftConfig.json file
     character(fnlen)  :: h5copypath
      !! location of the HDF5 h5copy program
     character(fnlen)  :: EMsoftplatform
      !! platform label (Darwin, Linux, Windows ... )
     character(fnlen)  :: EMsofttestpath
      !! path for test programs
     character(fnlen)  :: EMsoftTestingPath
      !! another path for test programs
     character(fnlen)  :: EMsoftversion
      !! EMsoft version string
     character(fnlen)  :: Configpath
      !! location of the EMsoftConfig.json file
     character(fnlen)  :: Templatepathname
      !! location of the name list template files
     character(fnlen)  :: Resourcepathname
      !! location the resources folder
     character(fnlen)  :: Xtalpathname
      !! path to the location of the .xtal file folder
     character(fnlen)  :: userHomepathname
      !! user home folder
     character(fnlen)  :: OpenCLpathname
      !! path to the OpenCL script folder
     character(fnlen)  :: Templatecodefilename
      !! name of the file that contains the template codes
     character(fnlen)  :: WyckoffPositionsfilename
      !! name of the file that encodes the Wyckoff positions
     character(fnlen)  :: Randomseedfilename
      !! name of the file that has random number seeds in it
     character(1)      :: EMsoftnativedelimiter
     ! character(fnlen)  :: strvals(wraparraysize)
     character(fnlen)  :: EMsoftRevision
      !! Git short hash
     character(fnlen)  :: EMsoftBuildDate
      !! Latest build date
     character(fnlen)  :: wikipathname
      !! path to the wiki resources
     character(fnlen)  :: User
      !! local system user name
     character(fnlen)  :: fftwWisdomfilename
      !! name of the fftw wisdom file
     character(fnlen)  :: wikicodefilename
      !! name of the files that contains the wiki file codes
     character(3)      :: EMsoftHDFtest
      !! equal to YES when the EMsoftHDFtest environmental parameter is set
     character(3)      :: EMsoftAllocatetest
      !! equal to YES when the EMsoftAllocatetest environmental parameter is set
     character(fnlen)  :: SlackWebHookURL
      !! URL for Slack messaging
     character(fnlen)  :: SlackChannel
      !! channel for Slack messaging
     character(fnlen), public  :: flagset = ''
      !! parameter used to communicate flags to the Interpret_Program_Arguments routines
     character(fnlen), public  :: nmldeffile

    contains
    private

! private methods
      procedure, pass(self) :: init
      procedure, pass(self) :: getEMsoftpathname
      procedure, pass(self) :: getXtalpathname
      procedure, pass(self) :: getEMdatapathname
      procedure, pass(self) :: getEMtmppathname
      procedure, pass(self) :: getSlackWebHookURL
      procedure, pass(self) :: getSlackChannel
      procedure, pass(self) :: getUsername
      procedure, pass(self) :: getUserlocation
      procedure, pass(self) :: getUseremail
      procedure, pass(self) :: getNotify
      procedure, pass(self) :: getEMdevelop
      procedure, pass(self) :: getRelease
      procedure, pass(self) :: geth5copypath
      procedure, pass(self) :: getEMsoftplatform
      procedure, pass(self) :: getEMsofttestpath
      procedure, pass(self) :: getEMsoftTestingPath
      procedure, pass(self) :: getEMsoftversion
      procedure, pass(self) :: getConfigpath
      procedure, pass(self) :: getTemplatepathname
      procedure, pass(self) :: getResourcepathname
      procedure, pass(self) :: getUserHomePath
      procedure, pass(self) :: getOpenCLpathname
      procedure, pass(self) :: getTemplatecodefilename
      procedure, pass(self) :: getWyckoffPositionsfilename
      procedure, pass(self) :: getRandomseedfilename
      procedure, pass(self) :: getEMsoftnativedelimiter
      procedure, pass(self) :: getEMsoftRevision
      procedure, pass(self) :: getEMsoftBuildDate
      procedure, pass(self) :: getEMXtalFolderpathname
      procedure, pass(self) :: getwikipathname
      procedure, pass(self) :: getUser
      procedure, pass(self) :: getfftwWisdomfilename
      procedure, pass(self) :: getwikicodefilename
      procedure, pass(self) :: getJSONparameter
      procedure, pass(self) :: getEMsoftHDFtest
      procedure, pass(self) :: getEMsoftAllocatetest
      procedure, pass(self) :: path_init
      procedure, pass(self) :: toNativePath_
      procedure, pass(self) :: fromNativePath_
      procedure, pass(self) :: ConvertWiki2PDF_
      procedure, pass(self) :: CopyTemplateFiles_
      procedure, pass(self) :: Interpret_Program_Arguments_with_nml_
      procedure, pass(self) :: Interpret_Program_Arguments_no_nml_

! public methods
! [there aren't many... just one to set each parameter, and one to get each parameter;
!  in addition there is one to init the EMsoft configuration file (used by the EMsoftinit program) ]
      procedure, pass(self), public :: setnmldeffile

      procedure, pass(self), public :: printEMsoftHeader

      procedure, pass(self), public :: getConfigParameter

      procedure, pass(self), public :: setConfigParameter

      procedure, pass(self), public :: printConfigParameters

      procedure, pass(self), public :: generateFilePath

      procedure, pass(self), public :: toNativePath => toNativePath_

      procedure, pass(self), public :: fromNativePath => fromNativePath_

      procedure, pass(self), public :: C2F_configuration_strings => C2F_configuration_strings_

      procedure, pass(self), public :: Check_Program_Argument

  end type EMsoft_T
! !DEC$ ATTRIBUTES DLLEXPORT :: setConfigParameter

! the constructor routine for this class
  interface EMsoft_T
    module procedure :: constructor
  end interface EMsoft_T

  private :: cstrlen, cstrf 

contains

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! we begin with the functions/subroutines that are public in this class
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
type(EMsoft_T) function constructor(progname, progdesc, makeconfig, showconfig, silent, tpl, noCLA) result(EMsoft)
!DEC$ ATTRIBUTES DLLEXPORT :: constructor
  !! author: MDG
  !! version: 1.0
  !! date: 12/30/19
  !!
  !! constructor for the EMsoft Class
  !!
  !! if 'makeconfig' is present, a new EMsoftConfig.json file will be created in $HOME/.config/EMsoft
  !!
  !! if 'showconfig' is present, a list of all configuration parameters will be shown
  !!
  !! if 'silent' is present, no output will be shown
  !!
  !! if 'tpl' is present, and the -t option is given to the calling program, then the
  !! template files listed in the tpl integer array will be copied to the user's working
  !! folder.  The codes can be found in the templatecodes.txt file in the resources folder.
  !!
  !! if 'flagset' is present, that means that additional command line argument tests need
  !! to be carried out, in particular a test to see if Wyckoff positions need to be used
  !! for the EMmkxtal program.  Other options may be added in the future.

IMPLICIT NONE

character(fnlen), INTENT(IN)      :: progname
 !! program name string
character(fnlen), INTENT(IN)      :: progdesc
 !! program descriptor string
logical, INTENT(IN), OPTIONAL     :: makeconfig
 !! optionally, generate the JSON configuration file
logical, INTENT(IN), OPTIONAL     :: showconfig
 !! optionally, print all the configuration parameters
logical, INTENT(IN), OPTIONAL     :: silent
 !! optionally, don't show any output
integer(kind=irg), INTENT(IN), OPTIONAL :: tpl(:)
 !! list of template files to be created
logical, INTENT(IN), OPTIONAL     :: noCLA
 !! turn off Command Line Argument handling

if (present(noCLA)) then
  if (noCLA.eqv..TRUE.) then ! we do not want command line argument handling
    call EMsoft % init()
    call EMsoft % printEMsoftHeader(progname, progdesc)
  end if
else
  call EMsoft % init()

  if (present(tpl).and.(.not.present(silent))) then
    call EMsoft % printEMsoftHeader(progname, progdesc, templatelist=tpl)
  else
    if (PRESENT(makeconfig)) then
      if (makeconfig) then
        call EMsoft % printEMsoftHeader(progname, progdesc, makeconfig)
      else
        if (.not.present(silent)) then
          call EMsoft % printEMsoftHeader(progname, progdesc)
        end if
      endif
    else
      if (.not.present(silent)) then
        call EMsoft % printEMsoftHeader(progname, progdesc)
      end if
    end if
  end if

  if (PRESENT(showconfig)) then
    if (showconfig) then
      call EMsoft % printConfigParameters
    endif
  end if
end if

end function constructor

!--------------------------------------------------------------------------
subroutine EMsoft_destructor(self)
!DEC$ ATTRIBUTES DLLEXPORT :: EMsoft_destructor
!! author: MDG
!! version: 1.0
!! date: 02/02/20
!!
!! destructor for the kvectors_T Class

IMPLICIT NONE

type(EMsoft_T), INTENT(INOUT)  :: self

call reportDestructor('EMsoft_T')

end subroutine EMsoft_destructor

!--------------------------------------------------------------------------
subroutine init(self)
!DEC$ ATTRIBUTES DLLEXPORT :: init
  !! author: MDG
  !! version: 1.0
  !! date: 12/30/19
  !!
  !! initializes all the components of EMsoftClass

  class(EMsoft_T),intent(inout) :: self

! fill in all the values; the first set MUST be done in this order ...
  call self % getEMsoftplatform()
  call self % getEMsoftnativedelimiter()
  call self % getUser()
  call self % getUserHomePath()
  call self % getConfigpath()
  call self % getEMsoftpathname()
  call self % getEMXtalFolderpathname()
  call self % getResourcepathname()
  call self % getTemplatepathname()
  call self % getTemplatecodefilename()

! from here on the order does not matter
  call self % getXtalpathname()
  call self % getEMdatapathname()
  call self % getEMtmppathname()
  call self % getSlackWebHookURL()
  call self % getSlackChannel()
  call self % getUsername()
  call self % getUserlocation()
  call self % getUseremail()
  call self % getNotify()
  call self % getEMdevelop()
  call self % getRelease()
  call self % geth5copypath()
  call self % getEMsofttestpath()
  call self % getEMsoftTestingPath()
  call self % getEMsoftversion()
  call self % getEMsoftPlatform()
  call self % getOpenCLpathname()
  call self % getWyckoffPositionsfilename()
  call self % getRandomseedfilename()
  call self % getEMsoftRevision()
  call self % getEMsoftBuildDate()
  call self % getwikipathname()
  call self % getfftwWisdomfilename()
  call self % getwikicodefilename()
  call self % getEMsoftHDFtest()
  call self % getEMsoftAllocatetest()

end subroutine init


!--------------------------------------------------------------------------
subroutine printConfigParameters(self)
!DEC$ ATTRIBUTES DLLEXPORT :: printConfigParameters

  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! prints all the components of EMsoftClass

  use mod_io

  IMPLICIT NONE

  class(EMsoft_T),intent(inout) :: self
  type(IO_T)               :: Message

  character(fnlen)              :: m

  call Message % printMessage( '<EMsoftConfigurationParameters> ' )
  call Message % printMessage( 'EMsoftpathname           = '//trim( self % EMsoftpathname ) )
  call Message % printMessage( 'EMXtalFolderpathname     = '//trim( self % EMXtalFolderpathname ) )
  call Message % printMessage( 'EMdatapathname           = '//trim( self % EMdatapathname ) )
  call Message % printMessage( 'EMtmppathname            = '//trim( self % EMtmppathname ) )
  call Message % printMessage( 'EMsoftLibraryLocation    = '//trim( self % EMsoftLibraryLocation ) )
  call Message % printMessage( 'EMSlackWebHookURL        = '//trim( self % SlackWebHookURL ) )
  call Message % printMessage( 'EMSlackChannel           = '//trim( self % SlackChannel ) )
  call Message % printMessage( 'UserName                 = '//trim( self % UserName ) )
  call Message % printMessage( 'UserLocation             = '//trim( self % UserLocation ) )
  call Message % printMessage( 'UserEmail                = '//trim( self % UserEmail ) )
  call Message % printMessage( 'EMNotify                 = '//trim( self % EMNotify ) )
  call Message % printMessage( 'Develop                  = '//trim( self % EMDevelop ) )
  call Message % printMessage( 'Release                  = '//trim( self % EMRelease ) )
  call Message % printMessage( 'h5copypath               = '//trim( self % h5copypath ) )
  call Message % printMessage( 'EMsoftplatform           = '//trim( self % EMsoftplatform ) )
  call Message % printMessage( 'EMsofttestpath           = '//trim( self % EMsofttestpath ) )
  call Message % printMessage( 'EMsoftTestingPath        = '//trim( self % EMsoftTestingPath ) )
  call Message % printMessage( 'EMsoftversion            = '//trim( self % EMsoftversion ) )
  call Message % printMessage( 'Configpath               = '//trim( self % Configpath ) )
  call Message % printMessage( 'Templatepathname         = '//trim( self % Templatepathname ) )
  call Message % printMessage( 'Resourcepathname         = '//trim( self % Resourcepathname ) )
  call Message % printMessage( 'Homepathname             = '//trim( self % userHomepathname ) )
  call Message % printMessage( 'OpenCLpathname           = '//trim( self % OpenCLpathname ) )
  call Message % printMessage( 'Templatecodefilename     = '//trim( self % Templatecodefilename ) )
  call Message % printMessage( 'WyckoffPositionsfilename = '//trim( self % WyckoffPositionsfilename ) )
  call Message % printMessage( 'Randomseedfilename       = '//trim( self % Randomseedfilename ) )
  call Message % printMessage( 'EMsoftnativedelimiter    = '//trim( self % EMsoftnativedelimiter ) )
  call Message % printMessage( 'EMsoftRevision           = '//trim( self % EMsoftRevision ) )
  call Message % printMessage( 'EMsoftBuildDate          = '//trim( self % EMsoftBuildDate ) )
  call Message % printMessage( 'wikipathname             = '//trim( self % wikipathname ) )
  call Message % printMessage( 'User                     = '//trim( self % User ) )
  call Message % printMessage( 'fftwWisdomfilename       = '//trim( self % fftwWisdomfilename ) )
  call Message % printMessage( 'wikicodefilename         = '//trim( self % wikicodefilename ) )
  call Message % printMessage( 'EMsoftHDFtest            = '//trim( self % EMsoftHDFtest ) )
  call Message % printMessage( 'EMsoftAllocatetest       = '//trim( self % EMsoftAllocatetest ) )
  call Message % printMessage( '</EMsoftConfigurationParameters> ' )

end subroutine printConfigParameters

!--------------------------------------------------------------------------
function getConfigParameter(self, inp) result(cp)
!DEC$ ATTRIBUTES DLLEXPORT :: getConfigParameter

  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! get a particular component of EMsoftClass

  class(EMsoft_T),intent(inout) :: self
  character(*),INTENT(IN)       :: inp
   !! string describing the requested configuration parameter

  character(fnlen)              :: cp

  select case(trim(inp))
    case('EMsoftpathname')
      cp = trim( self % EMsoftpathname )
    case('EMXtalFolderpathname')
      cp = trim( self % EMXtalFolderpathname )
    case('EMdatapathname')
      cp = trim( self % EMdatapathname )
    case('EMtmppathname')
      cp = trim( self % EMtmppathname )
    case('EMsoftLibraryLocation')
      cp = trim( self % EMsoftLibraryLocation )
    case('SlackWebHookURL')
      cp = trim( self % SlackWebHookURL )
    case('SlackChannel')
      cp = trim( self % SlackChannel )
    case('UserName')
      cp = trim( self % UserName )
    case('UserLocation')
      cp = trim( self % UserLocation )
    case('UserEmail')
      cp = trim( self % UserEmail )
    case('EMNotify')
      cp = trim( self % EMNotify )
    case('Develop')
      cp = trim( self % EMDevelop )
    case('Release')
      cp = trim( self % EMRelease )
    case('h5copypath')
      cp = trim( self % h5copypath )
    case('EMsoftplatform')
      cp = trim( self % EMsoftplatform )
    case('EMsofttestpath')
      cp = trim( self % EMsofttestpath )
    case('EMsoftTestingPath')
      cp = trim( self % EMsoftTestingPath )
    case('EMsoftversion')
      cp = trim( self % EMsoftversion )
    case('Configpath')
      cp = trim( self % Configpath )
    case('Templatepathname')
      cp = trim( self % Templatepathname )
    case('Resourcepathname')
      cp = trim( self % Resourcepathname )
    case('Homepathname')
      cp = trim( self % userHomepathname )
    case('OpenCLpathname')
      cp = trim( self % OpenCLpathname )
    case('Templatecodefilename')
      cp = trim( self % Templatecodefilename )
    case('WyckoffPositionsfilename')
      cp = trim( self % WyckoffPositionsfilename )
    case('Randomseedfilename')
      cp = trim( self % Randomseedfilename )
    case('EMsoftnativedelimiter')
      cp = trim( self % EMsoftnativedelimiter )
    case('EMsoftRevision')
      cp = trim( self % EMsoftRevision )
    case('EMsoftBuildDate')
      cp = trim( self % EMsoftBuildDate )
    case('wikipathname')
      cp = trim( self % wikipathname )
    case('User')
      cp = trim( self % User )
    case('fftwWisdomfilename')
      cp = trim( self % fftwWisdomfilename )
    case('wikicodefilename')
      cp = trim( self % wikicodefilename )
    case('EMsoftHDFtest')
      cp = trim( self % EMsoftHDFtest )
    case('EMsoftAllocatetest')
      cp = trim( self % EMsoftAllocatetest )
    case default
      cp = 'unknown configuration parameter'
  end select

! and use the correct delimiter for this platform
  if (trim(inp).ne.'SlackWebHookURL') cp = toNativePath_(self, cp)

end function getConfigParameter

!--------------------------------------------------------------------------
subroutine setConfigParameter(self, inp, value)
!DEC$ ATTRIBUTES DLLEXPORT :: setConfigParameter
  !! author: MDG
  !! version: 1.0
  !! date: 01/05/20
  !!
  !! set a particular component of EMsoft_T

  class(EMsoft_T),intent(inout) :: self
  character(*),INTENT(IN)       :: inp
   !! string describing the requested configuration parameter
  character(*),INTENT(IN)       :: value
   !! string with the new value

  character(fnlen)              :: cp

  select case(trim(inp))
    case('EMsoftpathname')
      self % EMsoftpathname = trim(value)
    case('EMXtalFolderpathname')
      self % EMXtalFolderpathname = trim(value)
    case('EMdatapathname')
      self % EMdatapathname = trim(value)
    case('EMtmppathname')
      self % EMtmppathname = trim(value)
    case('EMsoftLibraryLocation')
      self % EMsoftLibraryLocation = trim(value)
    case('SlackWebHookURL')
      self % SlackWebHookURL = trim(value)
    case('SlackChannel')
      self % SlackChannel = trim(value)
    case('UserName')
      self % UserName = trim(value)
    case('UserLocation')
      self % UserLocation = trim(value)
    case('UserEmail')
      self % UserEmail = trim(value)
    case('EMNotify')
      self % EMNotify = trim(value)
    case('Develop')
      self % EMDevelop = trim(value)
    case('Release')
      self % EMRelease = trim(value)
    case('h5copypath')
      self % h5copypath = trim(value)
    case('EMsoftplatform')
      self % EMsoftplatform = trim(value)
    case('EMsofttestpath')
      self % EMsofttestpath = trim(value)
    case('EMsoftTestingPath')
      self % EMsoftTestingPath = trim(value)
    case('EMsoftversion')
      self % EMsoftversion = trim(value)
    case('Configpath')
      self % Configpath = trim(value)
    case('Templatepathname')
      self % Templatepathname = trim(value)
    case('Resourcepathname')
      self % Resourcepathname = trim(value)
    case('Homepathname')
      self % userHomepathname = trim(value)
    case('OpenCLpathname')
      self % OpenCLpathname = trim(value)
    case('Templatecodefilename')
      self % Templatecodefilename = trim(value)
    case('WyckoffPositionsfilename')
      self % WyckoffPositionsfilename = trim(value)
    case('Randomseedfilename')
      self % Randomseedfilename = trim(value)
    case('EMsoftnativedelimiter')
      self % EMsoftnativedelimiter = trim(value)
    case('EMsoftRevision')
      self % EMsoftRevision = trim(value)
    case('EMsoftBuildDate')
      self % EMsoftBuildDate = trim(value)
    case('wikipathname')
      self % wikipathname = trim(value)
    case('User')
      self % User = trim(value)
    case('fftwWisdomfilename')
      self % fftwWisdomfilename = trim(value)
    case('wikicodefilename')
      self % wikicodefilename = trim(value)
    case('EMsoftHDFtest')
      self % EMsoftHDFtest = trim(value)
    case('EMsoftAllocatetest')
      self % EMsoftAllocatetest = trim(value)
    case default
      cp = 'unknown configuration parameter'
  end select

end subroutine setConfigParameter

!--------------------------------------------------------------------------
function generateFilePath(self, cp, fn) result(fp)
!DEC$ ATTRIBUTES DLLEXPORT :: generateFilePath

  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! complete a file path

  use mod_io

  IMPLICIT NONE

  class(EMsoft_T),intent(inout)      :: self
  character(*),INTENT(IN)            :: cp
   !! configuration parameter string
  character(*),INTENT(IN),OPTIONAL   :: fn
   !! optional file name with incomplete path
  character(fnlen)                   :: fp
   !! completed file name (returned)

  character(fnlen)                   :: path

  type(IO_T)                    :: Message

  path = trim(self % getConfigParameter(cp))

  if (trim(path).eq.'unknown configuration parameter') then    ! report error and exit
    Message = IO_T()
    call Message % printError('generateFilePath',' unknown configuration parameter')
  else
    if (present(fn)) then
      fp = trim(path)//trim(fn)           ! prepend the path
    else
      fp = trim(path)                     ! this is already a complete file name ...
    end if
    fp = toNativePath_(self, fp)  ! and use the correct delimiter for this platform
  end if

end function generateFilePath

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! from here on, we have the older functions (all private) that are called
! by the new class functions
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------


!--------------------------------------------------------------------------
subroutine getEMsoftpathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftpathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMsoftpathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: EMsoftpathname, ep, envParam, envReturn, m
integer                           :: l, status
type(IO_T)                        :: Message


ep = SC_EMsoftpathname
self % EMsoftpathname = getJSONparameter(self, ep)

if (trim(self%EMsoftpathname).eq.'tryEnvironmentVariable') then
  envParam = 'EMSOFTPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then
    self%EMsoftpathname = trim(envReturn)
    l = len(trim(self%EMsoftpathname))
    if ( (self%EMsoftpathname(l:l).ne.'/') .and. (self%EMsoftpathname(l:l).ne.'\') ) then  !'
      self%EMsoftpathname = trim(self%EMsoftpathname)//'/'
    end if
  else
    Message = IO_T()
    status = 999001
    call Message % printError('EMsoftpathname was not defined in the json file', &
                   status, (/ 'EMSOFTPATHNAME environment variable was NOT defined as a backup.'/))
  end if
end if

end subroutine getEMsoftpathname


!--------------------------------------------------------------------------
subroutine getEMXtalFolderpathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMXtalFolderpathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMXtalFolderpathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

type(IO_T)                         :: Message
character(fnlen)                   :: ep, envParam, envReturn
integer                            :: l

ep = SC_EMXtalFolderpathname
self%EMXtalFolderpathname = getJSONparameter(self, ep)

if (trim(self%EMXtalFolderpathname).eq.'tryEnvironmentVariable') then
  envParam = 'EMXTALFOLDERPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then
    self%EMXtalFolderpathname = trim(envReturn)
    l = len(trim(self%EMXtalFolderpathname))
    if ( (self%EMXtalFolderpathname(l:l).ne.'/') .and. (self%EMXtalFolderpathname(l:l).ne.'\') ) then !'
      self%EMXtalFolderpathname = trim(self%EMXtalFolderpathname)//'/'
    end if
  else
    if (displayEMsoftWarningMessages.eq.0) then
      Message = IO_T()
      call Message % printWarning('EMXtalFolderpathname was not defined in the json file', &
                     (/ 'EMXTALFOLDERPATHNAME environment variable was NOT defined as a backup.', &
                        '----> using absolute path convention                                  '/) )
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    self%EMXtalFolderpathname = ''
  end if
end if

end subroutine getEMXtalFolderpathname

!--------------------------------------------------------------------------
subroutine getXtalpathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getXtalpathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the xtalpathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%xtalpathname = trim(self%EMXtalFolderpathname)

end subroutine getXtalpathname

!--------------------------------------------------------------------------
subroutine getEMdatapathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMdatapathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMdatapathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

type(IO_T)                        :: Message
character(fnlen)                  :: ep, envParam, envReturn
integer                           :: l

ep = SC_EMdatapathname
self%EMdatapathname = getJSONparameter(self, ep)

if (trim(self%EMdatapathname).eq.'tryEnvironmentVariable') then
  envParam = 'EMDATAPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then
    self%EMdatapathname = trim(envReturn)
    l = len(trim(self%EMdatapathname))
    if ( (self%EMdatapathname(l:l).ne.'/') .and. (self%EMdatapathname(l:l).ne.'\') ) then !'
      self%EMdatapathname = trim(self%EMdatapathname)//'/'
    end if
  else
    if (displayEMsoftWarningMessages.eq.0) then
      Message = IO_T()
      call Message % printWarning('EMdatapathname was not defined in the json file', &
                     (/ 'EMDATAPATHNAME environment variable was NOT defined as a backup.', &
                        '----> using absolute path convention                            '/) )
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    self%EMdatapathname = ''
  end if
end if

end subroutine getEMdatapathname


!--------------------------------------------------------------------------
subroutine getEMtmppathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMtmppathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMtmppathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

type(IO_T)                    :: Message
character(fnlen)                   :: ep, envParam, envReturn
integer                            :: l

ep = SC_EMtmppathname
self%EMtmppathname = getJSONparameter(self, ep)

if (trim(self%EMtmppathname).eq.'tryEnvironmentVariable') then
  envParam = 'EMTMPPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then
    self%EMtmppathname = trim(envReturn)
    l = len(trim(self%EMtmppathname))
    if ( (self%EMtmppathname(l:l).ne.'/') .and. (self%EMtmppathname(l:l).ne.'\')) then !'
      self%EMtmppathname = trim(self%EMtmppathname)//'/'
    end if
  else
    if (displayEMsoftWarningMessages.eq.0) then
      Message = IO_T()
      call Message % printWarning('EMtmppathname was not defined in the json file', &
                     (/ 'EMTMPPATHNAME environment variable was NOT defined as a backup.', &
                        '----> using absolute path convention                           '/) )
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    self%EMtmppathname = ''
  end if
end if

end subroutine getEMtmppathname

!--------------------------------------------------------------------------
subroutine getSlackWebHookURL(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getSlackWebHookURL
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the URL for the Slack Webhook to send message to the user

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: ep

ep = SC_EMSlackWebHookURL
self%SlackWebHookURL = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getSlackWebHookURL

!--------------------------------------------------------------------------
subroutine getSlackChannel(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getSlackChannel
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the Slack Channel to send message to the user

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep

ep = SC_EMSlackChannel
self%SlackChannel = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getSlackChannel

!--------------------------------------------------------------------------
subroutine getUsername(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getUsername
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the Username variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep, envParam, envReturn, loginname

ep = SC_UserName
self%username = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(self%username).eq.'tryEnvironmentVariable') then
  envParam = 'USERNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then
    self%username = trim(envReturn)
  else
    call getlog(loginname)
    self%username = trim(loginname)
  end if
end if

end subroutine getUsername

!--------------------------------------------------------------------------
subroutine getUserlocation(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getUserlocation
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the userlocation variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep, envParam, envReturn, hostname

ep = SC_UserLocation
self%userlocation = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(self%userlocation).eq.'tryEnvironmentVariable') then
  envParam = 'USERlocation'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then
    self%userlocation = trim(envReturn)
  else
    call hostnm(hostname)
    self%userlocation = trim(hostname)
  end if
end if

end subroutine getUserlocation

!--------------------------------------------------------------------------
subroutine getUseremail(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getUseremail
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the useremail variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep, envParam, envReturn, hostname

ep = SC_UserEmail
self%useremail = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(self%useremail).eq.'tryEnvironmentVariable') then
  self%useremail = 'undefined'
end if

end subroutine getUseremail

!--------------------------------------------------------------------------
subroutine getNotify(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getNotify
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMNotify variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: ep

ep = SC_EMNotify
self%EMNotify = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getNotify

!--------------------------------------------------------------------------
subroutine getEMdevelop(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMdevelop
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! check whether or not the Develop keyword is present in the config file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                        :: EMstring, ep, envParam, envReturn
logical                                 :: EMdevelop

! default: not in developer mode
EMdevelop = .FALSE.

ep = SC_Develop
EMstring = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(EMstring).eq.'Yes') then
  EMdevelop = .TRUE.
else if (trim(EMstring).eq.'tryEnvironmentVariable') then
       envParam = 'EMdevelop'
       call getenv(trim(envParam),envReturn)
       if (trim(envReturn).eq.'Yes') EMdevelop = .TRUE.
     end if

if (EMdevelop.eqv..TRUE.) then
  self%EMdevelop = 'Yes'
else
  self%EMdevelop = 'No'
end if

end subroutine getEMdevelop

!--------------------------------------------------------------------------
subroutine getRelease(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getRelease
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! check whether or not the Release keyword is present in the config file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep

ep = SC_Release
self%EMRelease = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getRelease

!--------------------------------------------------------------------------
subroutine getEMsoftplatform(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftplatform
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMsoftplatform

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftplatform = "@CMAKE_SYSTEM_NAME@"

end subroutine getEMsoftplatform

!--------------------------------------------------------------------------
subroutine geth5copypath(self)
!DEC$ ATTRIBUTES DLLEXPORT :: geth5copypath
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the location of the h5copy program

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

if (trim(self%EMsoftplatform).eq.SC_Windows) then
  self%h5copypath = "@HDF5_INSTALL@"//SC_h5copy//".exe"
else
  self%h5copypath = "@HDF5_INSTALL@"//SC_h5copy
end if

end subroutine geth5copypath

!--------------------------------------------------------------------------
subroutine getEMsofttestpath(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsofttestpath
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMsofttestpath variable

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: binarypath

binarypath = "@EMsoftOO_BINARY_DIR@"

self%EMsofttestpath = trim(toNativePath_(self, binarypath))&
                        //self%EMsoftnativedelimiter//SC_Testing&
                        //self%EMsoftnativedelimiter//SC_Temporary

end subroutine getEMsofttestpath

!--------------------------------------------------------------------------
subroutine getEMsoftTestingPath(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftTestingPath
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! Returns the path to the EMsoft binary directory

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftTestingpath = "@EMsoftOO_TESTING_DIR@"

end subroutine getEMsoftTestingPath

!--------------------------------------------------------------------------
subroutine getEMsoftversion(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftversion
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the Version Information

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftversion = "@EMsoftOO_VER_MAJOR@_@EMsoftOO_VER_MINOR@_@EMsoftOO_VER_PATCH@_@EMsoftOO_VERSION_TWEAK@"

end subroutine getEMsoftversion

!--------------------------------------------------------------------------
subroutine getConfigpath(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getConfigpath
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the path for the configuration file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%configpath = trim(self%userHomePathname)//self%EMsoftnativedelimiter//SC_config &
                  //self%EMsoftnativedelimiter//SC_EMsoft//self%EMsoftnativedelimiter

end subroutine getConfigpath

!--------------------------------------------------------------------------
subroutine getTemplatepathname(self, json)
!DEC$ ATTRIBUTES DLLEXPORT :: getTemplatepathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the templatepathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

logical,INTENT(IN),OPTIONAL        :: json

if (present(json)) then
  if (json.eqv..TRUE.) then
    self%templatepathname = trim(self%EMsoftpathname)//SC_JSONTemplates//self%EMsoftnativedelimiter
  else
    self%templatepathname = trim(self%EMsoftpathname)//SC_NamelistTemplates//self%EMsoftnativedelimiter
  end if
else
  self%templatepathname = trim(self%EMsoftpathname)//SC_NamelistTemplates//self%EMsoftnativedelimiter
end if

end subroutine getTemplatepathname

!--------------------------------------------------------------------------
subroutine getResourcepathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getResourcepathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the resourcepathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%resourcepathname = trim(self%EMsoftpathname)//SC_resources//self%EMsoftnativedelimiter

end subroutine getResourcepathname

!--------------------------------------------------------------------------
subroutine getUserHomePath(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getUserHomePath
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the user home folder

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(9)      :: Home
character(2)      :: HomeDrive

HomeDrive = ''
if (trim(self%EMsoftplatform).eq.SC_Windows) then
  Home = 'HOMEPATH'
  call getenv("HOMEDRIVE",HomeDrive)
else
  Home = 'HOME'
end if

call getenv(trim(Home),self%userHomePathName)
self%userHomePathName = trim(HomeDrive)//trim(self%userHomePathName)

end subroutine getUserHomePath

!--------------------------------------------------------------------------
subroutine getOpenCLpathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getOpenCLpathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the openclpathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%openclpathname = trim(self%EMsoftpathname)//SC_opencl//self%EMsoftnativedelimiter

end subroutine getOpenCLpathname

!--------------------------------------------------------------------------
subroutine getTemplatecodefilename(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getTemplatecodefilename
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the templatecodefilename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%templatecodefilename = trim(self%Resourcepathname)//SC_templatecodestxt

end subroutine getTemplatecodefilename

!--------------------------------------------------------------------------
subroutine getWyckoffPositionsfilename(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getWyckoffPositionsfilename
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the Wyckoff Positions filename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%WyckoffPositionsfilename = trim(self%Resourcepathname)//SC_WyckoffPositionstxt

end subroutine getWyckoffPositionsfilename

!--------------------------------------------------------------------------
subroutine getRandomseedfilename(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getRandomseedfilename
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the randomseedfilename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%randomseedfilename = trim(self%Resourcepathname)//SC_RandomSeedsdata

end subroutine getRandomseedfilename

!--------------------------------------------------------------------------
subroutine getEMsoftnativedelimiter(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftnativedelimiter
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the native delimiter for file paths

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

if (trim(self%EMsoftplatform).eq.SC_Windows) then
  self%EMsoftnativedelimiter = '\'  ! ' <- this single prime inside a comment prevents syntax issues with some source code editors
else
  self%EMsoftnativedelimiter = '/'
end if

end subroutine getEMsoftnativedelimiter

!--------------------------------------------------------------------------
subroutine getEMsoftRevision(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftRevision
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the Git Hash of the current commit.

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftrevision = "@EMsoftOO_SHORT_GIT_HASH@"

end subroutine getEMsoftRevision

!--------------------------------------------------------------------------
subroutine getEMsoftBuildDate(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftBuildDate
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the build time stamp

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftBuildDate = "@EMsoftOO_BUILD_TIMESTAMP@"

end subroutine getEMsoftBuildDate

!--------------------------------------------------------------------------
subroutine getwikipathname(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getwikipathname
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the wikipathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%wikipathname = trim(self%EMsoftpathname)//SC_wiki//self%EMsoftnativedelimiter

end subroutine getwikipathname

!--------------------------------------------------------------------------
subroutine getUser(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getUser
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the system user name

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(9)                       :: User
character(fnlen)                   :: uName

User = 'USER'

call getenv(trim(User),uName)
self%User = trim(uName)

end subroutine getUser

!--------------------------------------------------------------------------
subroutine getfftwWisdomfilename(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getfftwWisdomfilename
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the filename of the fftw wisdom file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%fftwWisdomfilename = trim(self%Resourcepathname)//SC_fftwwisdomtxt

end subroutine getfftwWisdomfilename

!--------------------------------------------------------------------------
subroutine getwikicodefilename(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getwikicodefilename
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the wikicodefilename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%wikicodefilename = trim(self%Resourcepathname)//SC_wikicodestxt

end subroutine getwikicodefilename

!--------------------------------------------------------------------------
subroutine getEMsoftHDFtest(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftHDFtest
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the EMsoftHDFtest environment variable

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: envParam, envReturn

envParam = 'EMsoftHDFtest'
call getenv(trim(envParam),envReturn)
self%EMsoftHDFtest = 'No'
if (trim(envReturn).ne.'') then
  self%EMsoftHDFtest = 'Yes'
end if

end subroutine getEMsoftHDFtest

!--------------------------------------------------------------------------
subroutine getEMsoftAllocatetest(self)
!DEC$ ATTRIBUTES DLLEXPORT :: getEMsoftAllocatetest
  !! author: MDG
  !! version: 1.0
  !! date: 3/24/21
  !!
  !! returns the EMsoftAllocatetest environment variable

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: envParam, envReturn

envParam = 'EMsoftAllocatetest'
call getenv(trim(envParam),envReturn)
self%EMsoftAllocatetest = 'No'
if (trim(envReturn).ne.'') then
  self%EMsoftAllocatetest = 'Yes'
end if

end subroutine getEMsoftAllocatetest

!--------------------------------------------------------------------------
subroutine setnmldeffile(self, nmlfile)
!DEC$ ATTRIBUTES DLLEXPORT :: setnmldeffile
  !! author: MDG
  !! version: 1.0
  !! date: 11/07/21
  !!
  !! sets the nmldeffile parameter 

IMPLICIT NONE

class(EMsoft_T),intent(inout)  :: self
character(*),intent(in)        :: nmlfile

self%nmldeffile = trim(nmlfile)

end subroutine setnmldeffile

!--------------------------------------------------------------------------
function getJSONparameter(self, ep, nobackslash) result(param)
!DEC$ ATTRIBUTES DLLEXPORT :: getJSONparameter
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! returns the ep variable from the EMsoftconfig.json file

use json_module

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)           :: self

character(fnlen),INTENT(IN)             :: ep
 !! JSON variable name string
logical,INTENT(IN),optional             :: nobackslash
 !! optionally, omit the backslash from the output string
character(fnlen)                        :: param
 !! subroutine return string

type(IO_T)                         :: Message
type(json_file)                         :: json
integer(kind=irg)                       :: error_cnt, slen
character(kind=jsonCK,len=:),allocatable:: cval
character(fnlen)                        :: jsonfilename, jsonname, mm(2)
logical                                 :: found, jexists, bs

Message = IO_T()

bs = .TRUE.
if (present(nobackslash)) then
  if (nobackslash.eqv..TRUE.) bs = .FALSE.
end if

jsonfilename = SC_jsonfilename
jsonname =  trim(self%Configpath)//self%EMsoftnativedelimiter//trim(jsonfilename)

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

if (jexists) then
! initialize the json state variables
  error_cnt = 0
  call json_initialize()
  if (json_failed()) then
    call json_print_error_message(error_unit)
    stop
  end if

! and load the file
  call json%load_file(filename = trim(jsonname))
  if (json_failed().eqv..TRUE.) then    !if there was an error reading the file
    call json_print_error_message(error_unit)
    stop
  end if

  call json%get(trim(ep), cval, found)
  if (.not. found) then
   if (trim(ep).eq.SC_Develop) then
     param = trim(ep)
   else
     mm(1) = 'field '//trim(ep)//' not found in json file: '//trim(jsonname)
     mm(2) = 'continuing with empty parameter value for '//trim(ep)
     call Message % printWarning('USER='//trim(self%User), mm)
     param = ''
   end if
  else
    param = trim(cval)
  end if

! and make sure there is a terminating EMsoftnativedeliter character, except when the
! field has zero length, in which case some other default behavior will be assumed; this
! last case was added on 08/15/17 to offer an alternative file location mechanism to the user, namely
! either a full path declaration or the current working folder, to complement the default
! behavior which is to prepend the contents of the datapathname configuration variable.
  slen = len(trim(cval))
  if ((slen.ne.0).and.(bs.eqv..TRUE.)) then
    if (cval(slen:slen).ne.self%EMsoftnativedelimiter) then
      param = trim(cval)//self%EMsoftnativedelimiter
    end if
  end if
else
  if (displayConfigFileMissingMessage.eq.0) then
    mm(1) = 'file '//trim(jsonname)//' not found '
    mm(2) = '  -----> Trying environment variables next ... '
    call Message % printWarning('  WARNING: USER='//trim(self%User), mm)
    displayConfigFileMissingMessage = 1
  end if
  param = 'tryEnvironmentVariable'
end if


end function getJSONparameter

!--------------------------------------------------------------------------
subroutine printEMsoftHeader(self, progname, progdesc, makeconfig, templatelist)
!DEC$ ATTRIBUTES DLLEXPORT :: printEMsoftHeader
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! prints a copyright statement as well as where the user can find the license information
  !! This is then followed by the program name, a one-line description, and a time stamp.
  !!
  !! 01/13/20: added templatelist optional parameter

use mod_io
use mod_timing

IMPLICIT NONE

class(EMsoft_T),intent(inout)           :: self
character(fnlen),INTENT(IN)             :: progname
 !! name of the calling program
character(fnlen),INTENT(IN)             :: progdesc
 !! description of what the calling program does
logical,INTENT(IN),OPTIONAL             :: makeconfig
 !! do we need to (optionally) generate the configuration file ?
integer(kind=irg),INTENT(IN),OPTIONAL   :: templatelist(:)

type(IO_T)                              :: Message
type(Timing_T)                          :: Timing
integer(kind=irg)                       :: sz(1), slen
character(fnlen)                        :: nmldefault

 Message = IO_T()

 call Message % printMessage('<EMsoftHeader>',frm="(/A/)")
 call Message % printMessage('Copyright (C) 2001-2023 Marc De Graef Research Group/CMU',frm="(A)")
 call Message % printMessage('EMsoft comes with ABSOLUTELY NO WARRANTY.')
 call Message % printMessage('This is free software, and you are welcome to redistribute it')
 call Message % printMessage('under certain conditions; see License.txt file for details.',frm="(A/)")

 call Message % printMessage('Program name         : '//trim(progname))
 call Message % printMessage('Purpose              : '//trim(progdesc))
 call Message % printMessage('Platform             : '//"@CMAKE_SYSTEM_NAME@")
 call Message % printMessage('Source code version  : '//trim(self % EMsoftversion))
 call Message % printMessage('Source code Revision : '//trim(self % EMsoftRevision))
 call Message % printMessage('Build Date/Time      : '//trim(self % EMsoftBuildDate),frm="(A/)")

 call Message % printMessage( 'See https://github.com/EMsoft-org/EMsoftOO/wiki for selected help pages.',frm="(A/)")

 Timing = Timing_T(showDateTime=.TRUE.)

 call Message % printMessage('</EMsoftHeader>',frm="(A/)")

 if (present(makeconfig)) then ! we need to (re-)create the EMsoftConfig.json file...
    if (makeconfig.eqv..TRUE.) then
      call self%path_init
    end if
 end if

 if (present(templatelist)) then
    sz = shape(templatelist)
    if (trim(self%flagset).ne.'') then
      call Interpret_Program_Arguments_no_nml_(self, sz(1), templatelist, progname)
    else
      slen = len(trim(progname))
      nmldefault = trim(progname)
! replace .f90 by .nml
      nmldefault(slen-2:slen-2) = 'n'
      nmldefault(slen-1:slen-1) = 'm'
      nmldefault(slen  :slen  ) = 'l'
      call Interpret_Program_Arguments_with_nml_(self, nmldefault, sz(1), templatelist, progname)
      self%nmldeffile = trim(nmldefault)
    end if
 end if

end subroutine printEMsoftHeader

!--------------------------------------------------------------------------
function toNativePath_(self, inpath) result(outpath)
!DEC$ ATTRIBUTES DLLEXPORT :: toNativePath_

  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! convert a path string from the native format to the other one

IMPLICIT NONE

class(EMsoft_T),intent(inout)    :: self

character(fnlen),INTENT(IN)           :: inpath
 !! path to be converted
character(fnlen)                      :: outpath
 !! output path

integer(kind=irg)                     :: i, slen
character(1)                          :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
todelim = self%EMsoftnativedelimiter

if (todelim.eq.'\') then    ! '
  fromdelim = '/'
else
  fromdelim = '\'           ! '
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function toNativePath_

!--------------------------------------------------------------------------
function fromNativePath_(self, inpath) result(outpath)
!DEC$ ATTRIBUTES DLLEXPORT :: fromNativePath_

  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! convert a path string to the native format on this platform

IMPLICIT NONE

class(EMsoft_T),intent(inout)        :: self

character(fnlen),INTENT(IN)          :: inpath
 !! input path to be converted
character(fnlen)                     :: outpath
 !! output path

integer(kind=irg)                    :: i, slen
character(1)                         :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
fromdelim = self%EMsoftnativedelimiter

if (fromdelim.eq.'/') then
  todelim = '\'      ! '
else
  todelim = '/'
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function fromNativePath_

!--------------------------------------------------------------------------
subroutine path_init(self)
!DEC$ ATTRIBUTES DLLEXPORT :: path_init
  !! author: MDG
  !! version: 1.0
  !! date: 12/31/19
  !!
  !! This routine is called at the start of every EMsoft program; first,
  !! we check to see whether or not the configuration file exists in .config/EMsoft.
  !! If it exists, we copy it to a different file name so that we can create a new one.
  !! If it does not exist, then we create it with some default parameters and ask the
  !! user for some others.

use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)           :: self

type(IO_T)                         :: Message
character(fnlen)                        :: pathstring, dirstring, ep, EMsoftpathname, EMdatapathname, &
                                           username, userlocn, useremail, m
integer(kind=irg)                       :: i, error_cnt
logical                                 :: found, fexists, jexists
character(fnlen)                        :: confname, emsoftname, jsonname, jsonfilename, fname, cwd, &
                                           dirname, library, dataname, xtalname
character(3)                            :: release, develop
character(len=1)                        :: edp, tab, yesno

edp = '"'
tab = CHAR(9)
yesno = 'n'
EMsoftpathname = ''
EMdatapathname = ''

! default names for the json configuration file
confname = SC_config
emsoftname = SC_EMsoft
jsonfilename = SC_jsonfilename

! get the config file name
jsonname = self % generateFilePath('Configpath',jsonfilename)

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

! if this routine is called with config=.TRUE. parameter, then that means that we
! must create a new EMsoftConfig.json file if it doesn't already exist; we will inform
! the user if it does exist, and rename the existing file
Message = IO_T()

if (jexists) then
  call Message % printMessage( (/ '-------                                                                         ', &
                                  'WARNING: An older configuration file already exists in the .config/EMsoft folder', &
                                  '         The existing file will be renamed and a new file created.              '/) )
  call Message % ReadValue('          Do you want to continue ? (y/n) ', yesno, frm="(A1)" )
  if (yesno.eq.'n') then
    stop 'program terminated'
  end if
  call Message % printMessage('         Renaming old file to '//trim(jsonname)//'.save')
  call Message % printMessage((/ '         Creating new configuration file', &
                                 '-------                                 '/) )
  if (trim(self % EMsoftplatform).ne.'Windows') then   ! use the UNIX rename command 'mv oldname newname'
    call system('mv '//trim(jsonname)//' '//trim(jsonname)//'.save')
  else   ! on Windows the file rename command is 'ren oldname newname'
    call system('ren '//trim(jsonname)//' '//trim(jsonname)//'.save')
  end if
end if

! look for the .config/EMsoft/EMsoftConfig.json file one step at a time
dirstring = self % userHomepathname
call chdir(trim(dirstring))

! check for the .config folder
dirname = trim(dirstring)//self % EMsoftnativedelimiter//trim(confname)
inquire(file=trim(dirname),exist=fexists)
if (.not.(fexists)) then
  call system('mkdir '//trim(dirname))
  call Message % printMessage(trim(dirname)//' folder did not exist and has been created')
end if
call chdir(trim(dirname))

! check for the EMsoft folder
dirname = trim(dirname)//self % EMsoftnativedelimiter//SC_EMsoft
inquire(file=trim(dirname),exist=fexists)
if (.not.(fexists)) then
  call system('mkdir '//trim(dirname))
  call Message % printMessage(trim(dirname)//' folder did not exist and has been created')
end if
call chdir(trim(dirname))

! check whether or not the tmp folder exists...
fname = trim(dirname)//self % EMsoftnativedelimiter//SC_tmp
inquire(file=trim(fname),exist=fexists)
if (.not.(fexists)) then
  call system('mkdir '//trim(fname))
  call Message % printMessage(trim(fname)//' folder did not exist and has been created')
end if

! ok, so we have created the correct folder structure; now we need to generate the
! skeleton EMsoftConfig.json file, which then needs to be edited by the user

release = 'No'
develop = 'No'

! generate the json file; in principle we can replace all of these with Message class statements,
! but there's really no reason to do so ...
open(unit=dataunit,file=trim(jsonname),status='new',form='formatted')
call Message % printMessage('{',redirect=dataunit)
write (dataunit,"(A,A,'EMsoftpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMXtalFolderpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMdatapathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMtmppathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(fname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMsoftLibraryLocation',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'Release',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(release), edp
write (dataunit,"(A,A,'Develop',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(develop), edp

call Message % printMessage((/ '-------                                                                ', &
                               'Please respond to the following questions (each entry < 132 characters)'/) )
call Message % ReadValue('  Enter your user name : ', username, frm="(A)" )
write (dataunit,"(A,A,'UserName',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(username), edp

call Message % ReadValue('  Enter your email address : ', useremail, frm="(A)" )
write (dataunit,"(A,A,'UserEmail',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(useremail), edp

call Message % ReadValue('  Enter your affiliation : ', userlocn, frm="(A)" )
write (dataunit,"(A,A,'UserLocation',A,': ',A,A,A)") tab, edp, edp, edp, trim(userlocn), edp

call Message % printMessage('}',redirect=dataunit)
close(unit=dataunit,status='keep')

call Message % printMessage( &
  (/'                                                                                                    ', &
    ' A skeleton EMsoftConfig.json file has been created in your .config/EMsoft folder.                  ', &
    ' You will need to edit this file to change the parameters from their default values.                ', &
    '                                                                                                    ', &
    ' - EMsoftpathname should point to the top folder of your EMsoft installation.                       ', &
    ' - EMdatapathname should point to where you want to keep all EMsoft output files.                   ', &
    '   Note that this folder should NOT be inside the EMsoftpathname folder!                            ', &
    '   You may leave this variable undefined (empty string) to force programs to                        ', &
    '   generate all files in the current working folder or to use full path file names.                 ', &
    ' - EMXtalFolderpathname should point to the folder that will contain the *.xtal files.              ', &
    ' - EMtmppathname should point to the tmp folder where the EMsoftConfig.json file is located.        ', &
    ' - EMsoftLibraryLocation is needed only if you have a fully subroutineal IDL installation; this     ', &
    '   variable should then point to the location of the EMsoftLib.dylib or EMsoftLib.dll file.         ', &
    ' - One of the variables Develop and Release should be set to Yes, the other to No; if you are       ', &
    '   developing new EMsoft code using the EMsoftPrivate folder, then set Develop to Yes               ', &
    '   and Release to No to indicate Debug mode. for regular users: Develop=No, Release=Yes             ', &
    ' - EMNotify can be set to Slack or Email to send program completion messages to the user            ', &
    ' - EMSlackWebHookURL and EMSlackChannel are used for Slack messages (see Package Configuration wiki)', &
    '                                                                                                    ', &
    ' Make sure that each non-empty pathname ends with /, even on Windows platforms !                    ', &
    '                                                                                                    ', &
    ' Every EMsoft program will read this configuration file to figure out where things are located.     '/) )

end subroutine path_init

!--------------------------------------------------------------------------
recursive subroutine ConvertWiki2PDF_(self, nt, wikilist)
!DEC$ ATTRIBUTES DLLEXPORT :: ConvertWiki2PDF_
  !! author: MDG
  !! version: 1.0
  !! date: 01/12/20
  !!
  !! programs that do not have a template file will have wiki codes starting at 900

use mod_io

IMPLICIT NONE

class(EMsoft_T),INTENT(INOUT)           :: self
integer(kind=irg),INTENT(IN)            :: nt
integer(kind=irg),INTENT(IN)            :: wikilist(nt)

type(IO_T)                              :: Message
logical                                 :: pandoc_found, fexist
integer(kind=irg)                       :: i, j, ios, nlines
integer(kind=irg),parameter             :: maxnumtemplates = 1024
character(fnlen)                        :: wikifiles(maxnumtemplates), wcf, tpl, input_name, output_name, wikipath, &
                                           pandoc_tpl, defcmd, line, cmd
character(3)                            :: wplextension = '.md'
character(4)                            :: pdfextension = '.pdf'


! first make sure that pandoc is available on this platform
! we'll ask for the version number, and if the returned output contains more than one line
! then the program is available; this will work on UNIX platforms but will need to be
! modified for Windows.
pandoc_found = .FALSE.
call system('pandoc -v | wc -l > linecount')
open(unit=dataunit,file='linecount',status='old',form='formatted')
read(dataunit,"(I10)") nlines
close(unit=dataunit,status='delete')
if (nlines.gt.1) pandoc_found=.TRUE.

if (pandoc_found.eqv..TRUE.) then
! read the wikifile resources file to get all relevant file names
  wcf = trim(generateFilePath(self, 'wikicodefilename' ))
  inquire(file=trim(wcf),exist=fexist)
  if (.not.fexist) then
    call Message%printError('ConvertWiki2PDF','wiki code file not found: '//wcf)
  end if

  open(UNIT=dataunit,FILE=trim(wcf), STATUS='old', FORM='formatted',ACCESS='sequential')

  wikifiles = ''
  do
   read(dataunit,'(I3.3,A)',iostat=ios) j, line
   if (ios.ne.0) then
    exit
   end if
   wikifiles(j+1) = trim(line)
  end do
  CLOSE(UNIT=dataunit, STATUS='keep')

! get the correct path for the wiki files
  wikipath = trim(generateFilePath(self, 'wikipathname' ))

! then get the pandoc default.latex location (in the resources folder)
  pandoc_tpl = trim(generateFilePath(self, 'Resourcepathname', 'default.latex' ) )
  inquire(file=trim(pandoc_tpl),exist=fexist)

  if (fexist.eqv..TRUE.) then
    defcmd = '-V fontsize=10pt --template '//trim(pandoc_tpl)
  else
    defcmd = ''
    call Message%printWarning(' the pandoc default.latex template file could not be found; continuing... ')
  end if

! loop over all relevant wiki files and generate the corresponding PDF file
  do i=1,nt
    tpl = trim(wikifiles(wikilist(i)+1))
    input_name = trim(wikipath)//trim(tpl)//trim(wplextension)
    input_name = toNativePath_(self, input_name)

    inquire(file=trim(input_name),exist=fexist)

    if (fexist.eqv..TRUE.) then  ! create a shell script that will call pandoc and generate the PDF file
      output_name = trim(tpl)//pdfextension
! example command string:
!  pandoc -V fontsize=10pt --template EMsoftResourcesFolder/default.latex -s EMGBOdm.md -o EMGBOdm.pdf
      cmd = 'pandoc '//trim(defcmd)//' -s '//trim(input_name)//' -o '//trim(output_name)
      open(unit=dataunit,file='wiki2pdf',status='unknown',form='formatted')
      write(dataunit,"(A)") '#!/bin/bash'
      write(dataunit,"(A)") 'cdir=`pwd`'
      write(dataunit,"(A)") 'cd '//trim(wikipath)
      write(dataunit,"(A)") trim(cmd)
      write(dataunit,"(A)") 'mv '//trim(output_name)//' ${cdir}'
      write(dataunit,"(A)") 'cd ${cdir}'
      close(unit=dataunit, status='keep')
      call system('chmod +x wiki2pdf')
      call system('./wiki2pdf')
      open(unit=dataunit,file='wiki2pdf',status='unknown',form='formatted')
      close(unit=dataunit, status='delete')
      call Message%printMessage(' wiki file converted to PDF: '//trim(output_name))
    else
      call Message%printMessage(' wiki file '//trim(input_name)//' not found; continuing ...')
    end if
  end do
else
  call Message%printError('ConvertWiki2PDF',' pandoc program not found in search PATH')
end if

end subroutine ConvertWiki2PDF_

!--------------------------------------------------------------------------
recursive subroutine CopyTemplateFiles_(self, nt, templatelist, json)
!DEC$ ATTRIBUTES DLLEXPORT :: CopyTemplateFiles_
  !! author: MDG
  !! version: 1.0
  !! date: 01/13/20
  !!
  !! copy template files into local folder
  !!
  !! In the resources folder, there is a text file called templatecodes.txt
  !! in which each template file is given a unique ID number.  The present routine
  !! receives the requested numbers and then looks at that file to figure out
  !! which template files need to be copied into the user's working directory.

use mod_io

IMPLICIT NONE

class(EMsoft_T),INTENT(INOUT)           :: self
integer(kind=irg),INTENT(IN)            :: nt
integer(kind=irg),INTENT(IN)            :: templatelist(*)
logical,INTENT(IN),OPTIONAL             :: json

type(IO_T)                              :: Message
integer(kind=irg),parameter             :: maxnumtemplates = 512
character(fnlen)                        :: templates(maxnumtemplates)
character(fnlen)                        :: input_name, output_name, tcf, tppath1, tppath2, tpl, tplextension
integer(kind=irg)                       :: ios, i, j, ipos
character(255)                          :: line
logical                                 :: fexist
character(3)                            :: develop

! first open and read the resources/templatecodes.txt file

tcf = trim(generateFilePath(self, 'Templatecodefilename') )
inquire(file=trim(tcf),exist=fexist)
if (.not.fexist) then
  call Message%printError('CopyTemplateFiles','template code file not found:'//tcf)
end if

open(UNIT=dataunit,FILE=trim(tcf), STATUS='old', FORM='formatted',ACCESS='sequential')

templates = ''
do
 read(dataunit,'(I3.3,A)',iostat=ios) j, line
 if (ios.ne.0) then
  exit
 end if
 templates(j+1) = trim(line)
end do
CLOSE(UNIT=dataunit, STATUS='keep')

tplextension = '.template'
if (present(json)) then
  if (json.eqv..TRUE.) then
    tppath1 = trim(getConfigParameter(self, 'Templatepathname' ) ) !  (json))
    tplextension = '.jtemplate'
  else
    tppath1 = trim(getConfigParameter(self, 'Templatepathname' ) )
  end if
else
  tppath1 = trim(getConfigParameter(self, 'Templatepathname' ) )
end if

! then, determine whether or not the user is working in develop mode by checking for the
! Develop keyword in the EMsoftconfig.json file... Regular users will only have a single
! NameListTemplates folder, but developers have two, so we need to make sure we check both
! locations.  The second location is the private folder...
develop = trim(getConfigParameter(self, 'EMdevelop') )
tppath2 = ''
if (develop.eq.'Yes') then
  ipos = index(tppath1,'Public')
  do i=1,ipos-1
    tppath2(i:i) = tppath1(i:i)
  end do
  if (present(json)) then
    if (json.eqv..TRUE.) then
      tcf = 'Private/JSONTemplates/'
    else
      tcf = 'Private/NamelistTemplates/'
    end if
  else
    tcf = 'Private/NamelistTemplates/'
  endif
  do i=ipos,ipos+26
    j = i-ipos+1
    tppath2(i:i) = tcf(j:j)
  end do
end if

do i=1,nt
 if (templatelist(i).lt.900) then  ! exclude programs that haev a wiki file but no template file
   tpl = trim(templates(templatelist(i)+1))
   input_name = trim(tppath1)//trim(tpl)//trim(tplextension)
   input_name = toNativePath_(self, input_name)

   inquire(file=trim(input_name),exist=fexist)
   if (.not.fexist) then
    if (develop.eq.'Yes') then
     input_name = trim(tppath2)//trim(tpl)//trim(tplextension)
     input_name = toNativePath_(self, input_name)
     inquire(file=trim(input_name),exist=fexist)
     if (.not.fexist) then
       call Message%printError('CopyTemplateFiles','template file '//trim(templates(templatelist(i)+1))// &
                               trim(tplextension)//' not found in either template folder')
     end if
    else
     call Message%printError('CopyTemplateFiles','template file '//trim(templates(templatelist(i)+1))// &
                             trim(tplextension)//' not found')
    end if
   end if
   output_name = trim(templates(templatelist(i)+1))//trim(tplextension)
   output_name = toNativePath_(self, output_name)
   open(UNIT=dataunit,FILE=trim(input_name), STATUS='old', FORM='formatted',ACCESS='sequential')
   open(UNIT=dataunit2,FILE=trim(output_name), STATUS='unknown', FORM='formatted',ACCESS='sequential')
   do
          read(dataunit,'(A)',iostat=ios) line
          if (ios.ne.0) then
            exit
          end if
          write(dataunit2,'(A)') trim(line)
    end do
   close(UNIT=dataunit, STATUS='keep')
   close(UNIT=dataunit2, STATUS='keep')
   call Message%printMessage('  -> created template file '//trim(templates(templatelist(i)+1))//&
                             trim(tplextension), frm = "(A)")
 end if
end do

end subroutine CopyTemplateFiles_

!--------------------------------------------------------------------------
recursive subroutine Interpret_Program_Arguments_with_nml_(self, nmldefault, numt, templatelist, progname)
!DEC$ ATTRIBUTES DLLEXPORT :: Interpret_Program_Arguments_with_nml_
  !! author: MDG
  !! version: 1.0
  !! date: 01/13/20
  !!
  !! copy template files into local folder
  !!
  !! interpret the command line arguments
  !!
  !! In the resources folder, there is a text file called templatecodes.txt
  !! in which each template file is given a unique ID number.  The present routine
  !! receives the requested numbers and then looks into the file to figure out
  !! which ones need to be copied.

use mod_io

IMPLICIT NONE

class(EMsoft_T), INTENT(INOUT)          :: self
character(fnlen),INTENT(INOUT)          :: nmldefault
!f2py intent(in,out) ::  nmldefault
integer(kind=irg),INTENT(IN)            :: numt
integer(kind=irg),INTENT(IN)            :: templatelist(numt)
character(fnlen),INTENT(IN)             :: progname

type(IO_T)                              :: Message
integer(kind=irg)                       :: numarg       ! number of command line arguments
integer(kind=irg)                       :: iargc        ! external function for command line
character(fnlen)                        :: arg          ! to be read from the command line
character(fnlen)                        :: nmlfile      ! nml file name
integer(kind=irg)                       :: i, io_int(1)
logical                                 :: haltprogram, json

json = .FALSE.

!numarg = iargc()
numarg = command_argument_count()
nmlfile = ''
nmlfile = trim(nmldefault)

if (numarg.gt.0) then
  io_int(1) = numarg
  call Message%WriteValue(' Number of command line arguments detected: ',io_int,1)
end if

haltprogram = .FALSE.
if (numarg.ge.1) haltprogram = .TRUE.

if (numarg.gt.0) then ! there is at least one argument
  do i=1,numarg
!   call getarg(i,arg)
    call get_command_argument(i,arg)
!    mess = 'Found the following argument: '//trim(arg); call Message("(/A/)")
! does the argument start with a '-' character?
    if (arg(1:1).eq.'-') then
      if (trim(arg).eq.'-h') then
        call Message%printMessage(' Program should be called as follows: ', frm = "(/A)")
        call Message%printMessage('        '//trim(progname)//' -h -t -j [nmlfile]', frm = "(A)")
        call Message%printMessage(' where nmlfile is an optional file name for the namelist file;', frm = "(A/)")
        call Message%printMessage(' If absent, the default name '''//trim(nmldefault)//''' will be used.', frm = "(A)")
        call Message%printMessage(' To create templates of all possible input files, type '//trim(progname)//' -t', frm = "(A)")
        call Message%printMessage(' To produce this message, type '//trim(progname)//' -h', frm = "(A)")
        call Message%printMessage(' All program arguments can be combined in the same order;  ', frm = "(A)")
        call Message%printMessage(' the argument without - will be interpreted as the input file name.', frm = "(A/)")
      end if
      if (trim(arg).eq.'-t') then
! with this option the program creates template namelist files in the current folder so that the
! user can edit them (file extension will be .template; should be changed by user to .nml)
        call Message%printMessage('Creating program name list template files:', frm = "(/A)")
        call CopyTemplateFiles_(self, numt, templatelist)
      end if
      if ( (trim(arg).eq.'-w').and.(trim(progname).eq.'EMmkxtal.f90') ) then
! the EMmkxtal program has a special switch for Wyckoff position entry so we need to turn off haltprogram
        haltprogram = .FALSE.
      end if
      if ( (trim(arg).eq.'-H').and.(trim(progname).eq.'EMmkxtal.f90') ) then
! there is an alternative switch -H to use the Hall Space Group symbols
        haltprogram = .FALSE.
      end if
      if (trim(arg).eq.'-pdf') then
! if the pandoc program is installed (for instance within the anaconda distribution)
! then the user can ask for the wiki manual page (if it exists) to be converted into a pdf
! file that will be placed in the current folder.
!
! example command to generate the pdf file for the EMGBOdm program:
!   pandoc -V fontsize=10pt --template ~/templates/default.latex -s EMGBOdm.md -o EMGBOdm.pdf
!
! We use the same template codes but now they are linked to the corresponding wiki file
! which should be located in a folder at the same level as the resources folder.
!
        call Message%printMessage(' User requested wiki-to-pdf conversion', frm = "(/A)")
        call ConvertWiki2PDF_(self, numt, templatelist)
      end if
      if (trim(arg).eq.'-j') then
        json = .TRUE.
! with this option the program creates template JSON files in the current folder so that the
! user can edit them (file extension will be .jsontemplate; should be changed by user to .json)
!
! It should be noted that the template files contain comment lines starting with the "!" character;
! this is not standard JSON (which does not allow for comment lines).  The EMsoft JSON files will
! first be filtered to remove all the comment lines before being passed to the json parser routine.
        call Message%printMessage('Creating program JSON template files:', frm = "(/A)")
        call CopyTemplateFiles_(self, numt,templatelist,json=json)
      end if
    else
! no, the first character is not '-', so this argument must be the filename
! If it is present, but any of the other arguments were present as well, then
! we stop the program.
      nmldefault = arg
      if (numarg.eq.1) haltprogram = .FALSE.
    end if
  end do
end if

if (haltprogram) then
  call Message%printMessage('To execute program, remove all flags except for nml/json input file name', frm = "(/A/)")
  stop
end if


end subroutine Interpret_Program_Arguments_with_nml_

!--------------------------------------------------------------------------
recursive subroutine Interpret_Program_Arguments_no_nml_(self, numt, templatelist, progname)
!DEC$ ATTRIBUTES DLLEXPORT :: Interpret_Program_Arguments_no_nml_
  !! author: MDG
  !! version: 1.0
  !! date: 01/13/20
  !!
  !! interpret the command line arguments
  !!
  !! This routine assumes that there is no template file, but there
  !! could still be a wiki file...

use mod_io

IMPLICIT NONE

class(EMsoft_T), INTENT(INOUT)          :: self
integer(kind=irg),INTENT(IN)            :: numt
integer(kind=irg),INTENT(IN)            :: templatelist(numt)
character(fnlen),INTENT(IN)             :: progname

type(IO_T)                              :: Message
integer(kind=irg)                       :: numarg       !< number of command line arguments
integer(kind=irg)                       :: iargc        !< external function for command line
character(fnlen)                        :: arg          !< to be read from the command line
character(fnlen)                        :: nmlfile      !< nml file name
integer(kind=irg)                       :: i, io_int(1)
logical                                 :: haltprogram, json, flags

json = .FALSE.

flags = .FALSE.
if (trim(self%flagset).ne.'') then
  flags = .TRUE.
end if

numarg = command_argument_count()

if (numarg.gt.0) then
  io_int(1) = numarg
  call Message%WriteValue('Number of command line arguments detected: ',io_int,1)
end if

haltprogram = .FALSE.
if (numarg.ge.1) haltprogram = .TRUE.

if (numarg.gt.0) then ! there is at least one argument
  do i=1,numarg
!   call getarg(i,arg)
    call get_command_argument(i,arg)
! does the argument start with a '-' character?
    if (arg(1:1).eq.'-') then
      if (trim(arg).eq.'-h') then
        call Message%printMessage(' Program should be called as follows: ', frm = "(/A)")
        call Message%printMessage('        '//trim(progname)//' -h -pdf ', frm = "(A)")
        call Message%printMessage(' To produce this message, type '//trim(progname)//' -h', frm = "(A)")
        call Message%printMessage(' use -pdf to produce a PDF help file if the corresponding wiki file exists ', frm = "(A)")
      end if
      if (trim(arg).eq.'-pdf') then
! if the pandoc program is installed (for instance within the anaconda distribution)
! then the user can ask for the wiki manual page (if it exists) to be converted into a pdf
! file that will be placed in the current folder.
!
! example command to generate the pdf file for the EMGBOdm program:
!   pandoc -V fontsize=10pt --template ~/templates/default.latex -s EMGBOdm.md -o EMGBOdm.pdf
!
! We use the same template codes but now they are linked to the corresponding wiki file
! which should be located in a folder at the same level as the resources folder.
!
        call Message%printMessage(' User requested wiki-to-pdf conversion', frm = "(/A)")
        call ConvertWiki2PDF_(self, numt, templatelist)
      end if
      if (flags.eqv..TRUE.) then
        if (trim(arg).eq.trim(self%flagset)) then
          self % flagset = 'yes'
          haltprogram = .FALSE.
        end if
      end if
    else
! no, the first character is not '-', so this argument must be the filename
! If it is present, but any of the other arguments were present as well, then
! we stop the program.
      nmlfile = arg
      if (numarg.eq.1) haltprogram = .FALSE.
    end if
  end do
end if

if (haltprogram) then
  call Message%printMessage('To execute program, remove all flags ', frm = "(/A/)")
  stop
end if

end subroutine Interpret_Program_Arguments_no_nml_

!--------------------------------------------------------------------------
recursive function Check_Program_Argument( self, testarg ) result(found)
!DEC$ ATTRIBUTES DLLEXPORT :: Check_Program_Argument
  !! author: MDG
  !! version: 1.0
  !! date: 11/20/22
  !!
  !! check for a particular command line argument 
  !!

IMPLICIT NONE

class(EMsoft_T), INTENT(INOUT)          :: self
character(*), INTENT(IN)                :: testarg 
logical                                 :: found 

integer(kind=irg)                       :: numarg, iargca, i 
character(fnlen)                        :: arg

found = .FALSE.

numarg = command_argument_count()
if (numarg.gt.0) then
  do i=1,numarg
    call get_command_argument(i,arg)
    if (trim(testarg).eq.trim(arg)) found = .TRUE.
  end do
end if

end function Check_Program_Argument

!--------------------------------------------------------------------------
subroutine C2F_configuration_strings_(self, cptr) 
!DEC$ ATTRIBUTES DLLEXPORT :: C2F_configuration_strings_
  !! author: MDG
  !! version: 1.0
  !! date: 04/14/21
  !!
  !! convert C-strings to standard f90 configuration strings

IMPLICIT NONE

class(EMsoft_T), INTENT(INOUT)          :: self 
type(c_ptr), INTENT(IN), value          :: cptr

character(kind=c_char), pointer         :: fptr(:,:)
integer(kind=irg)                       :: ii, lenstr

call c_f_pointer(cptr, fptr, [ fnlen, wraparraysize ])

call self%setConfigParameter('EMsoftpathname', cstrf(fptr(1:fnlen,1)))
call self%setConfigParameter('EMXtalFolderpathname', cstrf(fptr(1:fnlen,2)))
call self%setConfigParameter('EMdatapathname', cstrf(fptr(1:fnlen,3)))
call self%setConfigParameter('EMtmppathname', cstrf(fptr(1:fnlen,4)))
call self%setConfigParameter('EMsoftLibraryLocation', cstrf(fptr(1:fnlen,5)))
call self%setConfigParameter('EMSlackWebHookURL', cstrf(fptr(1:fnlen,6)))
call self%setConfigParameter('EMSlackChannel', cstrf(fptr(1:fnlen,7)))
call self%setConfigParameter('UserName', cstrf(fptr(1:fnlen,8)))
call self%setConfigParameter('UserLocation', cstrf(fptr(1:fnlen,9)))
call self%setConfigParameter('UserEmail', cstrf(fptr(1:fnlen,10)))
call self%setConfigParameter('EMNotify', cstrf(fptr(1:fnlen,11)))
call self%setConfigParameter('Develop', cstrf(fptr(1:fnlen,12)))
call self%setConfigParameter('Release', cstrf(fptr(1:fnlen,13)))
call self%setConfigParameter('h5copypath', cstrf(fptr(1:fnlen,14)))
call self%setConfigParameter('EMsoftplatform', cstrf(fptr(1:fnlen,15)))
call self%setConfigParameter('EMsofttestpath', cstrf(fptr(1:fnlen,16)))
call self%setConfigParameter('EMsoftTestingPath', cstrf(fptr(1:fnlen,17)))
call self%setConfigParameter('EMsoftversion', cstrf(fptr(1:fnlen,18)))
call self%setConfigParameter('Configpath', cstrf(fptr(1:fnlen,19)))
call self%setConfigParameter('Templatepathname', cstrf(fptr(1:fnlen,20)))
call self%setConfigParameter('Resourcepathname', cstrf(fptr(1:fnlen,21)))
call self%setConfigParameter('Homepathname', cstrf(fptr(1:fnlen,22)))
call self%setConfigParameter('OpenCLpathname', cstrf(fptr(1:fnlen,23)))
call self%setConfigParameter('Templatecodefilename', cstrf(fptr(1:fnlen,24)))
call self%setConfigParameter('WyckoffPositionsfilename', cstrf(fptr(1:fnlen,25)))
call self%setConfigParameter('Randomseedfilename', cstrf(fptr(1:fnlen,26)))
call self%setConfigParameter('EMsoftnativedelimiter', cstrf(fptr(1:fnlen,27)))

end subroutine C2F_configuration_strings_

!--------------------------------------------------------------------------
!
! FUNCTION: cstrlen
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief compute the length of a null-terminated C string
!
!> @date 10/28/17 MDG 1.0 original
!--------------------------------------------------------------------------
function cstrlen(carray) result(res)

IMPLICIT NONE

character(kind=c_char), INTENT(IN) :: carray(:)
integer(kind=irg)                  :: res

integer(kind=irg)                  :: ii

res = size(carray)
do ii = 1, size(carray)
  if (carray(ii) == C_NULL_CHAR) then
    res = ii - 1
    return
  end if
end do

end function cstrlen

!--------------------------------------------------------------------------
!
! FUNCTION: cstrf
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a c string into a correctly formatted f string
!
!> @date 11/30/17 MDG 1.0 original
!--------------------------------------------------------------------------
function cstrf(carray) result(res)

IMPLICIT NONE

character(kind=c_char), INTENT(IN) :: carray(:)
character(fnlen)                   :: res

integer(kind=irg)                  :: ii, lenstr

lenstr = cstrlen(carray)
res = ''
do ii = 1, lenstr
    res(ii:ii) = carray(ii)
end do

end function cstrf




end module mod_EMsoft
