! ###################################################################
! Copyright (c) 2014-2020 Marc De Graef/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this
!        list of conditions and the following disclaimer in the documentation and/or
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names
!        of its contributors may be used to endorse or promote products derived from
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################

!---------------------------
! THIS FILE IS AUTOMATICALLY GENERATED DURING CMAKE TIME. THE ORIGINAL FILE
! LOCATED AT @CTEMSoftLib_SOURCE_DIR@/mod_EMsoft.in.f90
! YOU NEED TO MAKE CHANGES TO THAT FILE. ANY CHANGES MADE TO THIS FILE WILL
! BE OVERWRITTEN THE NEXT TIME CMAKE IS EXECUTED.
!---------------------------

module mod_EMsoft
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/30/19
  !!
  !! This class provides access to all the configuration parameters from the config file,
  !! as well as any command line or environment parameters that are relevant.  Upon starting any
  !! EMsoft program, the following lines should be included:
  !!
  !!   use mod_global
  !!
  !!   use mod_EMsoft
  !!
  !!   character(fnlen)        :: progname = 'this is the program name'
  !!
  !!   character(fnlen)        :: progdesc = 'and this is the descriptor'
  !!
  !!   type(EMsoft_T)     :: EMsoft 
  !!
  !!   ! this is a call to the constructor routine
  !!
  !!   EMsoft = EMsoft_T(progname, progdesc[,makeconfig][,showconfig])    
  !!
  !! This will print the usual start up message with copyright, build date, version, etc. info.
  !! It will also initialize all the configuration parameters; these are then available to the 
  !! calling program by means of the getConfigParameter method. The setConfigParameter method can
  !! be used to explicitly override any of the config parameters in this class. 
  !!
  !! The optional arguments to the constructor can be used to create the EMsoftConfig.json file 
  !! (using makeconfig=.TRUE.), or to simply print out all the configuration parameters (using 
  !! showconfig=.TRUE.).
  !!
  !! Finally, the method generateFilePath can be used to complete any given file path; in the old 
  !! f90 code this was done in three consecutive lines that were always basically the same, and here
  !! we provide a method to simply return the file name completed with the full path. 

use mod_kinds
use mod_global
use stringconstants
use, intrinsic :: ISO_C_BINDING
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit

IMPLICIT NONE

private
public :: EMsoft_T 

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

  type, public   ::  EMsoft_T
    !! EMsoft Class definition 
    private 
     character(fnlen)  :: EMsoftpathname
      !! path to the top of the EMsoft distribution
     character(fnlen)  :: EMXtalFolderpathname
      !! path to the location of the .xtal file folder 
     character(fnlen)  :: EMdatapathname
      !! path to the location of all data files 
     character(fnlen)  :: EMtmppathname
      !! path to a temporary folder 
     character(fnlen)  :: EMsoftLibraryLocation
      !! location of the main dylib/dll file, used only for IDL applications
     character(fnlen)  :: UserName
      !! user name 
     character(fnlen)  :: UserLocation
      !! user location 
     character(fnlen)  :: UserEmail
      !! user email (used for messaging)
     character(5)      :: EMNotify
      !! is messaging enabled? (Email or Slack)
     character(3)      :: EMDevelop
      !! is this a development installation (Yes/No)
     character(3)      :: EMRelease
      !! is this a release version (Yes/No)
! other configuration parameters that may be needed in various programs but are not in the EMsoftConfig.json file
     character(fnlen)  :: h5copypath
      !! location of the HDF5 h5copy program 
     character(fnlen)  :: EMsoftplatform
      !! platform label (Darwin, Linux, Windows ... )
     character(fnlen)  :: EMsofttestpath
      !! path for test programs 
     character(fnlen)  :: EMsoftTestingPath
      !! another path for test programs 
     character(fnlen)  :: EMsoftversion
      !! EMsoft version string 
     character(fnlen)  :: Configpath
      !! location of the EMsoftConfig.json file 
     character(fnlen)  :: Templatepathname
      !! location of the name list template files 
     character(fnlen)  :: Resourcepathname
      !! location the resources folder 
     character(fnlen)  :: Xtalpathname
      !! path to the location of the .xtal file folder 
     character(fnlen)  :: userHomepathname
      !! user home folder 
     character(fnlen)  :: OpenCLpathname
      !! path to the OpenCL script folder 
     character(fnlen)  :: Templatecodefilename
      !! name of the file that contains the template codes 
     character(fnlen)  :: WyckoffPositionsfilename
      !! name of the file that encodes the Wyckoff positions 
     character(fnlen)  :: Randomseedfilename
      !! name of the file that has random number seeds in it
     character(1)      :: EMsoftnativedelimiter
     ! character(fnlen)  :: strvals(wraparraysize)
     character(fnlen)  :: EMsoftRevision
      !! Git short hash 
     character(fnlen)  :: EMsoftBuildDate
      !! Latest build date 
     character(fnlen)  :: wikipathname
      !! path to the wiki resources 
     character(fnlen)  :: User
      !! local system user name 
     character(fnlen)  :: fftwWisdomfilename
      !! name of the fftw wisdom file 
     character(fnlen)  :: wikicodefilename
      !! name of the files that contains the wiki file codes
     character(3)      :: EMsoftHDFtest
      !! equal to YES when the EMsoftHDFtest environmental parameter is set
     character(fnlen)  :: SlackWebHookURL
      !! URL for Slack messaging
     character(fnlen)  :: SlackChannel
      !! channel for Slack messaging 

    contains
    private 

! private methods
      procedure, pass(self) :: init
      procedure, pass(self) :: printEMsoftHeader
      procedure, pass(self) :: getEMsoftpathname
      procedure, pass(self) :: getXtalpathname
      procedure, pass(self) :: getEMdatapathname
      procedure, pass(self) :: getEMtmppathname
      procedure, pass(self) :: getSlackWebHookURL
      procedure, pass(self) :: getSlackChannel
      procedure, pass(self) :: getUsername
      procedure, pass(self) :: getUserlocation
      procedure, pass(self) :: getUseremail
      procedure, pass(self) :: getNotify
      procedure, pass(self) :: getEMdevelop
      procedure, pass(self) :: getRelease
      procedure, pass(self) :: geth5copypath
      procedure, pass(self) :: getEMsoftplatform
      procedure, pass(self) :: getEMsofttestpath
      procedure, pass(self) :: getEMsoftTestingPath
      procedure, pass(self) :: getEMsoftversion
      procedure, pass(self) :: getConfigpath
      procedure, pass(self) :: getTemplatepathname
      procedure, pass(self) :: getResourcepathname
      procedure, pass(self) :: getUserHomePath
      procedure, pass(self) :: getOpenCLpathname
      procedure, pass(self) :: getTemplatecodefilename
      procedure, pass(self) :: getWyckoffPositionsfilename
      procedure, pass(self) :: getRandomseedfilename
      procedure, pass(self) :: getEMsoftnativedelimiter
      procedure, pass(self) :: getEMsoftRevision
      procedure, pass(self) :: getEMsoftBuildDate
      procedure, pass(self) :: getEMXtalFolderpathname
      procedure, pass(self) :: getwikipathname
      procedure, pass(self) :: getUser
      procedure, pass(self) :: getfftwWisdomfilename
      procedure, pass(self) :: getwikicodefilename
      procedure, pass(self) :: getJSONparameter
      procedure, pass(self) :: getEMsoftHDFtest
      procedure, pass(self) :: path_init


! public methods
! [there aren't many... just one to set each parameter, and one to get each parameter;
!  in addition there is one to init the EMsoft configuration file (used by the EMsoftinit program) ]
      procedure, pass(self), public :: getConfigParameter
      !DEC$ ATTRIBUTES DLLEXPORT :: getConfigParameter
      procedure, pass(self), public :: setConfigParameter
     ! !DEC$ ATTRIBUTES DLLEXPORT :: setConfigParameter
      procedure, pass(self), public :: printConfigParameters
      !DEC$ ATTRIBUTES DLLEXPORT :: printConfigParameters
      procedure, pass(self), public :: generateFilePath
      !DEC$ ATTRIBUTES DLLEXPORT :: generateFilePath

  end type EMsoft_T

! the constructor routine for this class 
  interface EMsoft_T
    module procedure :: constructor
    !DEC$ ATTRIBUTES DLLEXPORT :: constructor
  end interface EMsoft_T

contains

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! we begin with the functions/subroutines that are public in this class
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
type(EMsoft_T) function constructor(progname, progdesc, makeconfig, showconfig) result(EMsoft)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/30/19
  !!
  !! constructor for the EMsoft Class 
  
IMPLICIT NONE

character(fnlen), INTENT(IN)      :: progname
 !! program name string
character(fnlen), INTENT(IN)      :: progdesc
 !! program descriptor string 
logical, INTENT(IN), OPTIONAL     :: makeconfig
 !! optionally, generate the JSON configuration file
logical, INTENT(IN), OPTIONAL     :: showconfig
 !! optionaly, print all the configuration parameters

  call EMsoft % init

  if (PRESENT(makeconfig)) then 
    if (makeconfig) then 
      call EMsoft % printEMsoftHeader(progname, progdesc, makeconfig)
    else
      call EMsoft % printEMsoftHeader(progname, progdesc)
    endif
  else 
      call EMsoft % printEMsoftHeader(progname, progdesc)
  end if

  if (PRESENT(showconfig)) then 
    if (showconfig) then 
      call EMsoft % printConfigParameters
    endif
  end if

end function constructor

!--------------------------------------------------------------------------
subroutine init(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/30/19
  !!
  !! initializes all the components of EMsoftClass

  class(EMsoft_T),intent(inout) :: self

! fill in all the values; the first set MUST be done in this order ... 
  call self % getEMsoftplatform()
  call self % getEMsoftnativedelimiter()
  call self % getUser()
  call self % getUserHomePath()
  call self % getConfigpath()
  call self % getEMsoftpathname()
  call self % getEMXtalFolderpathname()
  call self % getResourcepathname()
  call self % getTemplatepathname()
  call self % getTemplatecodefilename()

! from here on the order does not matter
  call self % getXtalpathname()
  call self % getEMdatapathname()
  call self % getEMtmppathname()
  call self % getSlackWebHookURL()
  call self % getSlackChannel()
  call self % getUsername()
  call self % getUserlocation()
  call self % getUseremail()
  call self % getNotify()
  call self % getEMdevelop()
  call self % getRelease()
  call self % geth5copypath()
  call self % getEMsofttestpath()
  call self % getEMsoftTestingPath()
  call self % getEMsoftversion()
  call self % getEMsoftPlatform()
  call self % getOpenCLpathname()
  call self % getWyckoffPositionsfilename()
  call self % getRandomseedfilename()
  call self % getEMsoftRevision()
  call self % getEMsoftBuildDate()
  call self % getwikipathname()
  call self % getfftwWisdomfilename()
  call self % getwikicodefilename()
  call self % getEMsoftHDFtest()

end subroutine init


!--------------------------------------------------------------------------
subroutine printConfigParameters(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! prints all the components of EMsoftClass

  use mod_io 

  IMPLICIT NONE 

  class(EMsoft_T),intent(inout) :: self
  type(IO_T)               :: Message 

  character(fnlen)              :: m

  call Message % printMessage( '<EMsoftConfigurationParameters> ' )
  call Message % printMessage( 'EMsoftpathname           = '//trim( self % EMsoftpathname ) )
  call Message % printMessage( 'EMXtalFolderpathname     = '//trim( self % EMXtalFolderpathname ) )
  call Message % printMessage( 'EMdatapathname           = '//trim( self % EMdatapathname ) )
  call Message % printMessage( 'EMtmppathname            = '//trim( self % EMtmppathname ) )
  call Message % printMessage( 'EMsoftLibraryLocation    = '//trim( self % EMsoftLibraryLocation ) )
  call Message % printMessage( 'EMSlackWebHookURL        = '//trim( self % SlackWebHookURL ) )
  call Message % printMessage( 'EMSlackChannel           = '//trim( self % SlackChannel ) )
  call Message % printMessage( 'UserName                 = '//trim( self % UserName ) )
  call Message % printMessage( 'UserLocation             = '//trim( self % UserLocation ) )
  call Message % printMessage( 'UserEmail                = '//trim( self % UserEmail ) )
  call Message % printMessage( 'EMNotify                 = '//trim( self % EMNotify ) )
  call Message % printMessage( 'Develop                  = '//trim( self % EMDevelop ) )
  call Message % printMessage( 'Release                  = '//trim( self % EMRelease ) )
  call Message % printMessage( 'h5copypath               = '//trim( self % h5copypath ) )
  call Message % printMessage( 'EMsoftplatform           = '//trim( self % EMsoftplatform ) )
  call Message % printMessage( 'EMsofttestpath           = '//trim( self % EMsofttestpath ) )
  call Message % printMessage( 'EMsoftTestingPath        = '//trim( self % EMsoftTestingPath ) )
  call Message % printMessage( 'EMsoftversion            = '//trim( self % EMsoftversion ) )
  call Message % printMessage( 'Configpath               = '//trim( self % Configpath ) )
  call Message % printMessage( 'Templatepathname         = '//trim( self % Templatepathname ) )
  call Message % printMessage( 'Resourcepathname         = '//trim( self % Resourcepathname ) )
  call Message % printMessage( 'Homepathname             = '//trim( self % userHomepathname ) )
  call Message % printMessage( 'OpenCLpathname           = '//trim( self % OpenCLpathname ) )
  call Message % printMessage( 'Templatecodefilename     = '//trim( self % Templatecodefilename ) )
  call Message % printMessage( 'WyckoffPositionsfilename = '//trim( self % WyckoffPositionsfilename ) )
  call Message % printMessage( 'Randomseedfilename       = '//trim( self % Randomseedfilename ) )
  call Message % printMessage( 'EMsoftnativedelimiter    = '//trim( self % EMsoftnativedelimiter ) )
  call Message % printMessage( 'EMsoftRevision           = '//trim( self % EMsoftRevision ) )
  call Message % printMessage( 'EMsoftBuildDate          = '//trim( self % EMsoftBuildDate ) )
  call Message % printMessage( 'wikipathname             = '//trim( self % wikipathname ) )
  call Message % printMessage( 'User                     = '//trim( self % User ) )
  call Message % printMessage( 'fftwWisdomfilename       = '//trim( self % fftwWisdomfilename ) )
  call Message % printMessage( 'wikicodefilename         = '//trim( self % wikicodefilename ) )
  call Message % printMessage( 'EMsoftHDFtest            = '//trim( self % EMsoftHDFtest ) )
  call Message % printMessage( '</EMsoftConfigurationParameters> ' )

end subroutine printConfigParameters

!--------------------------------------------------------------------------
function getConfigParameter(self, inp) result(cp)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! get a particular component of EMsoftClass

  class(EMsoft_T),intent(inout) :: self
  character(*),INTENT(IN)       :: inp
   !! string describing the requested configuration parameter 

  character(fnlen)              :: cp

  select case(trim(inp))
    case('EMsoftpathname')
      cp = trim( self % EMsoftpathname )
    case('EMXtalFolderpathname')
      cp = trim( self % EMXtalFolderpathname )
    case('EMdatapathname')
      cp = trim( self % EMdatapathname )
    case('EMtmppathname')
      cp = trim( self % EMtmppathname )
    case('EMsoftLibraryLocation')
      cp = trim( self % EMsoftLibraryLocation )
    case('SlackWebHookURL')
      cp = trim( self % SlackWebHookURL )
    case('SlackChannel')
      cp = trim( self % SlackChannel )
    case('UserName')
      cp = trim( self % UserName )
    case('UserLocation')
      cp = trim( self % UserLocation )
    case('UserEmail')
      cp = trim( self % UserEmail )
    case('EMNotify')
      cp = trim( self % EMNotify )
    case('Develop')
      cp = trim( self % EMDevelop )
    case('Release')
      cp = trim( self % EMRelease )
    case('h5copypath')
      cp = trim( self % h5copypath )
    case('EMsoftplatform')
      cp = trim( self % EMsoftplatform )
    case('EMsofttestpath')
      cp = trim( self % EMsofttestpath )
    case('EMsoftTestingPath')
      cp = trim( self % EMsoftTestingPath )
    case('EMsoftversion')
      cp = trim( self % EMsoftversion )
    case('Configpath')
      cp = trim( self % Configpath )
    case('Templatepathname')
      cp = trim( self % Templatepathname )
    case('Resourcepathname')
      cp = trim( self % Resourcepathname )
    case('Homepathname')
      cp = trim( self % userHomepathname )
    case('OpenCLpathname')
      cp = trim( self % OpenCLpathname )
    case('Templatecodefilename')
      cp = trim( self % Templatecodefilename )
    case('WyckoffPositionsfilename')
      cp = trim( self % WyckoffPositionsfilename )
    case('Randomseedfilename')
      cp = trim( self % Randomseedfilename )
    case('EMsoftnativedelimiter')
      cp = trim( self % EMsoftnativedelimiter )
    case('EMsoftRevision')
      cp = trim( self % EMsoftRevision )
    case('EMsoftBuildDate')
      cp = trim( self % EMsoftBuildDate )
    case('wikipathname')
      cp = trim( self % wikipathname )
    case('User')
      cp = trim( self % User )
    case('fftwWisdomfilename')
      cp = trim( self % fftwWisdomfilename )
    case('wikicodefilename')
      cp = trim( self % wikicodefilename )
    case('EMsoftHDFtest')
      cp = trim( self % EMsoftHDFtest )
    case default
      cp = 'unknown configuration parameter'
  end select 

end function getConfigParameter

!--------------------------------------------------------------------------
subroutine setConfigParameter(self, inp, value)
  !! author: MDG 
  !! version: 1.0 
  !! date: 01/05/20
  !!
  !! set a particular component of EMsoft_T

  class(EMsoft_T),intent(inout) :: self
  character(*),INTENT(IN)       :: inp
   !! string describing the requested configuration parameter 
  character(*),INTENT(IN)       :: value 
   !! string with the new value

  character(fnlen)              :: cp

  select case(trim(inp))
    case('EMsoftpathname')
      self % EMsoftpathname = trim(value)
    case('EMXtalFolderpathname')
      self % EMXtalFolderpathname = trim(value)
    case('EMdatapathname')
      self % EMdatapathname = trim(value)
    case('EMtmppathname')
      self % EMtmppathname = trim(value)
    case('EMsoftLibraryLocation')
      self % EMsoftLibraryLocation = trim(value)
    case('SlackWebHookURL')
      self % SlackWebHookURL = trim(value)
    case('SlackChannel')
      self % SlackChannel = trim(value)
    case('UserName')
      self % UserName = trim(value)
    case('UserLocation')
      self % UserLocation = trim(value)
    case('UserEmail')
      self % UserEmail = trim(value)
    case('EMNotify')
      self % EMNotify = trim(value)
    case('Develop')
      self % EMDevelop = trim(value)
    case('Release')
      self % EMRelease = trim(value)
    case('h5copypath')
      self % h5copypath = trim(value)
    case('EMsoftplatform')
      self % EMsoftplatform = trim(value)
    case('EMsofttestpath')
      self % EMsofttestpath = trim(value)
    case('EMsoftTestingPath')
      self % EMsoftTestingPath = trim(value)
    case('EMsoftversion')
      self % EMsoftversion = trim(value)
    case('Configpath')
      self % Configpath = trim(value)
    case('Templatepathname')
      self % Templatepathname = trim(value)
    case('Resourcepathname')
      self % Resourcepathname = trim(value)
    case('Homepathname')
      self % userHomepathname = trim(value)
    case('OpenCLpathname')
      self % OpenCLpathname = trim(value)
    case('Templatecodefilename')
      self % Templatecodefilename = trim(value)
    case('WyckoffPositionsfilename')
      self % WyckoffPositionsfilename = trim(value)
    case('Randomseedfilename')
      self % Randomseedfilename = trim(value)
    case('EMsoftnativedelimiter')
      self % EMsoftnativedelimiter = trim(value)
    case('EMsoftRevision')
      self % EMsoftRevision = trim(value)
    case('EMsoftBuildDate')
      self % EMsoftBuildDate = trim(value)
    case('wikipathname')
      self % wikipathname = trim(value)
    case('User')
      self % User = trim(value)
    case('fftwWisdomfilename')
      self % fftwWisdomfilename = trim(value)
    case('wikicodefilename')
      self % wikicodefilename = trim(value)
    case('EMsoftHDFtest')
      self % EMsoftHDFtest = trim(value)
    case default
      cp = 'unknown configuration parameter'
  end select 

end subroutine setConfigParameter

!--------------------------------------------------------------------------
function generateFilePath(self, cp, fn) result(fp)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! complete a file path

  use mod_io 

  IMPLICIT NONE 

  class(EMsoft_T),intent(inout) :: self
  character(*),INTENT(IN)            :: cp    
   !! configuration parameter string 
  character(*),INTENT(IN),OPTIONAL   :: fn    
   !! optional file name with incomplete path 
  character(fnlen)                   :: fp    
   !! completed file name (returned)

  character(fnlen)                   :: path 

  type(IO_T)                    :: Message

  path = trim(self % getConfigParameter(cp))

  if (trim(path).eq.'unknown configuration parameter') then    ! report error and exit 
    Message = IO_T()
    call Message % printError('generateFilePath',' unknown configuration parameter')
  else 
    if (present(fn)) then 
      fp = trim(path)//trim(fn)           ! prepend the path 
    else 
      fp = trim(path)                     ! this is already a complete file name ... 
    end if 
    fp = toNativePath(self, fp)  ! and use the correct delimiter for this platform 
  end if

end function generateFilePath

!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! from here on, we have the older functions (all private) that are called 
! by the new class functions 
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------


!--------------------------------------------------------------------------
subroutine getEMsoftpathname(self) 
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMsoftpathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io 

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: EMsoftpathname, ep, envParam, envReturn, m
integer                            :: l, status
type(IO_T)                    :: Message 


ep = SC_EMsoftpathname
self % EMsoftpathname = getJSONparameter(self, ep)

if (trim(self%EMsoftpathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMSOFTPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    self%EMsoftpathname = trim(envReturn)
    l = len(trim(self%EMsoftpathname))
    if (self%EMsoftpathname(l:l).ne.'/') self%EMsoftpathname = trim(self%EMsoftpathname)//'/'
  else
    Message = IO_T()
    status = 999001
    call Message % printError('EMsoftpathname was not defined in the json file', &
                   status, (/ 'EMSOFTPATHNAME environment variable was NOT defined as a backup.'/))
  end if
end if 

end subroutine getEMsoftpathname


!--------------------------------------------------------------------------
subroutine getEMXtalFolderpathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMXtalFolderpathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

type(IO_T)                         :: Message
character(fnlen)                        :: ep, envParam, envReturn
integer                                 :: l

ep = SC_EMXtalFolderpathname
self%EMXtalFolderpathname = getJSONparameter(self, ep)

if (trim(self%EMXtalFolderpathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMXTALFOLDERPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    self%EMXtalFolderpathname = trim(envReturn)
    l = len(trim(self%EMXtalFolderpathname))
    if (self%EMXtalFolderpathname(l:l).ne.'/') self%EMXtalFolderpathname = trim(self%EMXtalFolderpathname)//'/'
  else
    if (displayEMsoftWarningMessages.eq.0) then 
      Message = IO_T()
      call Message % printWarning('EMXtalFolderpathname was not defined in the json file', &
                     (/ 'EMXTALFOLDERPATHNAME environment variable was NOT defined as a backup.', &
                        '----> using absolute path convention                                  '/) )
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    self%EMXtalFolderpathname = ''
  end if
end if 

end subroutine getEMXtalFolderpathname

!--------------------------------------------------------------------------
subroutine getXtalpathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the xtalpathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%xtalpathname = trim(self%EMXtalFolderpathname)

end subroutine getXtalpathname

!--------------------------------------------------------------------------
subroutine getEMdatapathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMdatapathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

type(IO_T)                    :: Message
character(fnlen)                   :: ep, envParam, envReturn
integer                            :: l

ep = SC_EMdatapathname
self%EMdatapathname = getJSONparameter(self, ep)

if (trim(self%EMdatapathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMDATAPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    self%EMdatapathname = trim(envReturn)
    l = len(trim(self%EMdatapathname))
    if (self%EMdatapathname(l:l).ne.'/') self%EMdatapathname = trim(self%EMdatapathname)//'/'
  else
    if (displayEMsoftWarningMessages.eq.0) then 
      Message = IO_T()
      call Message % printWarning('EMdatapathname was not defined in the json file', &
                     (/ 'EMDATAPATHNAME environment variable was NOT defined as a backup.', &
                        '----> using absolute path convention                            '/) )
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    self%EMdatapathname = ''
  end if
end if 

end subroutine getEMdatapathname


!--------------------------------------------------------------------------
subroutine getEMtmppathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMtmppathname variable from the EMsoftconfig.json file

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

type(IO_T)                    :: Message
character(fnlen)                   :: ep, envParam, envReturn
integer                            :: l

ep = SC_EMtmppathname
self%EMtmppathname = getJSONparameter(self, ep)

if (trim(self%EMtmppathname).eq.'tryEnvironmentVariable') then 
  envParam = 'EMTMPPATHNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    self%EMtmppathname = trim(envReturn)
    l = len(trim(self%EMtmppathname))
    if (self%EMtmppathname(l:l).ne.'/') self%EMtmppathname = trim(self%EMtmppathname)//'/'
  else
    if (displayEMsoftWarningMessages.eq.0) then 
      Message = IO_T()
      call Message % printWarning('EMtmppathname was not defined in the json file', &
                     (/ 'EMTMPPATHNAME environment variable was NOT defined as a backup.', &
                        '----> using absolute path convention                           '/) )
      displayEMsoftWarningMessages = displayEMsoftWarningMessages+1
    end if
    self%EMtmppathname = ''
  end if
end if 

end subroutine getEMtmppathname

!--------------------------------------------------------------------------
subroutine getSlackWebHookURL(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the URL for the Slack Webhook to send message to the user

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: ep

ep = SC_EMSlackWebHookURL
self%SlackWebHookURL = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getSlackWebHookURL

!--------------------------------------------------------------------------
subroutine getSlackChannel(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the Slack Channel to send message to the user

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep

ep = SC_EMSlackChannel
self%SlackChannel = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getSlackChannel

!--------------------------------------------------------------------------
subroutine getUsername(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the Username variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep, envParam, envReturn, loginname

ep = SC_UserName
self%username = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(self%username).eq.'tryEnvironmentVariable') then 
  envParam = 'USERNAME'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    self%username = trim(envReturn)
  else
    call getlog(loginname)
    self%username = trim(loginname)
  end if
end if 

end subroutine getUsername

!--------------------------------------------------------------------------
subroutine getUserlocation(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the userlocation variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep, envParam, envReturn, hostname

ep = SC_UserLocation
self%userlocation = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(self%userlocation).eq.'tryEnvironmentVariable') then 
  envParam = 'USERlocation'
  call getenv(trim(envParam),envReturn)
  if (trim(envReturn).ne.'') then 
    self%userlocation = trim(envReturn)
  else
    call hostnm(hostname)
    self%userlocation = trim(hostname)
  end if
end if 

end subroutine getUserlocation

!--------------------------------------------------------------------------
subroutine getUseremail(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the useremail variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep, envParam, envReturn, hostname

ep = SC_UserEmail
self%useremail = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(self%useremail).eq.'tryEnvironmentVariable') then 
  self%useremail = 'undefined'
end if

end subroutine getUseremail

!--------------------------------------------------------------------------
subroutine getNotify(self) 
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMNotify variable from the EMsoftconfig.json file

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: ep

ep = SC_EMNotify
self%EMNotify = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getNotify

!--------------------------------------------------------------------------
subroutine getEMdevelop(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! check whether or not the Develop keyword is present in the config file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                        :: EMstring, ep, envParam, envReturn
logical                                 :: EMdevelop

! default: not in developer mode
EMdevelop = .FALSE.

ep = SC_Develop
EMstring = getJSONparameter(self, ep, nobackslash=.TRUE.)

if (trim(EMstring).eq.'Yes') then 
  EMdevelop = .TRUE.
else if (trim(EMstring).eq.'tryEnvironmentVariable') then
       envParam = 'EMdevelop'
       call getenv(trim(envParam),envReturn)
       if (trim(envReturn).eq.'Yes') EMdevelop = .TRUE.
     end if

if (EMdevelop.eqv..TRUE.) then 
  self%EMdevelop = 'Yes'
else
  self%EMdevelop = 'No'
end if 

end subroutine getEMdevelop

!--------------------------------------------------------------------------
subroutine getRelease(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! check whether or not the Release keyword is present in the config file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: ep

ep = SC_Release
self%EMRelease = getJSONparameter(self, ep, nobackslash=.TRUE.)

end subroutine getRelease

!--------------------------------------------------------------------------
subroutine getEMsoftplatform(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMsoftplatform

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftplatform = "@CMAKE_SYSTEM_NAME@"

end subroutine getEMsoftplatform

!--------------------------------------------------------------------------
subroutine geth5copypath(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the location of the h5copy program

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

if (trim(self%EMsoftplatform).eq.SC_Windows) then
  self%h5copypath = "@HDF5_INSTALL@"//SC_h5copy//".exe"
else
  self%h5copypath = "@HDF5_INSTALL@"//SC_h5copy
end if

end subroutine geth5copypath

!--------------------------------------------------------------------------
subroutine getEMsofttestpath(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMsofttestpath variable

IMPLICIT NONE

class(EMsoft_T),intent(inout)     :: self

character(fnlen)                  :: binarypath

binarypath = "@EMsoftOO_BINARY_DIR@"

self%EMsofttestpath = trim(toNativePath(self, binarypath))&
                        //self%EMsoftnativedelimiter//SC_Testing&
                        //self%EMsoftnativedelimiter//SC_Temporary

end subroutine getEMsofttestpath

!--------------------------------------------------------------------------
subroutine getEMsoftTestingPath(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! Returns the path to the EMsoft binary directory

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftTestingpath = "@EMsoftOO_TESTING_DIR@"

end subroutine getEMsoftTestingPath

!--------------------------------------------------------------------------
subroutine getEMsoftversion(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the Version Information

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftversion = "@EMsoftOO_VER_MAJOR@_@EMsoftOO_VER_MINOR@_@EMsoftOO_VER_PATCH@_@EMsoftOO_VERSION_TWEAK@"

end subroutine getEMsoftversion

!--------------------------------------------------------------------------
subroutine getConfigpath(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the path for the configuration file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%configpath = trim(self%userHomePathname)//self%EMsoftnativedelimiter//SC_config &
                  //self%EMsoftnativedelimiter//SC_EMsoft//self%EMsoftnativedelimiter

end subroutine getConfigpath

!--------------------------------------------------------------------------
subroutine getTemplatepathname(self, json)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the templatepathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

logical,INTENT(IN),OPTIONAL        :: json

if (present(json)) then
  if (json.eqv..TRUE.) then
    self%templatepathname = trim(self%EMsoftpathname)//SC_JSONTemplates//self%EMsoftnativedelimiter
  else
    self%templatepathname = trim(self%EMsoftpathname)//SC_NamelistTemplates//self%EMsoftnativedelimiter
  end if
else
  self%templatepathname = trim(self%EMsoftpathname)//SC_NamelistTemplates//self%EMsoftnativedelimiter
end if

end subroutine getTemplatepathname

!--------------------------------------------------------------------------
subroutine getResourcepathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the resourcepathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%resourcepathname = trim(self%EMsoftpathname)//SC_resources//self%EMsoftnativedelimiter

end subroutine getResourcepathname

!--------------------------------------------------------------------------
subroutine getUserHomePath(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the user home folder 

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(9)      :: Home
character(2)      :: HomeDrive

HomeDrive = ''
if (trim(self%EMsoftplatform).eq.SC_Windows) then
  Home = 'HOMEPATH'
  call getenv("HOMEDRIVE",HomeDrive)
else
  Home = 'HOME'
end if

call getenv(trim(Home),self%userHomePathName)
self%userHomePathName = trim(HomeDrive)//trim(self%userHomePathName)

end subroutine getUserHomePath

!--------------------------------------------------------------------------
subroutine getOpenCLpathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the openclpathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%openclpathname = trim(self%EMsoftpathname)//SC_opencl//self%EMsoftnativedelimiter

end subroutine getOpenCLpathname

!--------------------------------------------------------------------------
subroutine getTemplatecodefilename(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the templatecodefilename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%templatecodefilename = trim(self%Resourcepathname)//SC_templatecodestxt

end subroutine getTemplatecodefilename

!--------------------------------------------------------------------------
subroutine getWyckoffPositionsfilename(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the Wyckoff Positions filename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%WyckoffPositionsfilename = trim(self%Resourcepathname)//SC_WyckoffPositionstxt

end subroutine getWyckoffPositionsfilename

!--------------------------------------------------------------------------
subroutine getRandomseedfilename(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the randomseedfilename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%randomseedfilename = trim(self%Resourcepathname)//SC_RandomSeedsdata

end subroutine getRandomseedfilename

!--------------------------------------------------------------------------
subroutine getEMsoftnativedelimiter(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the native delimiter for file paths

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

if (trim(self%EMsoftplatform).eq.SC_Windows) then
  self%EMsoftnativedelimiter = '\'  ! ' <- this single prime inside a comment prevents syntax issues with some source code editors 
else
  self%EMsoftnativedelimiter = '/'
end if

end subroutine getEMsoftnativedelimiter

!--------------------------------------------------------------------------
subroutine getEMsoftRevision(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the Git Hash of the current commit.

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftrevision = "@EMsoftOO_SHORT_GIT_HASH@"

end subroutine getEMsoftRevision

!--------------------------------------------------------------------------
subroutine getEMsoftBuildDate(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the build time stamp

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%EMsoftBuildDate = "@EMsoftOO_BUILD_TIMESTAMP@"

end subroutine getEMsoftBuildDate

!--------------------------------------------------------------------------
subroutine getwikipathname(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the wikipathname

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%wikipathname = trim(self%EMsoftpathname)//SC_wiki//self%EMsoftnativedelimiter

end subroutine getwikipathname

!--------------------------------------------------------------------------
subroutine getUser(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the system user name

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(9)                       :: User
character(fnlen)                   :: uName

User = 'USER'

call getenv(trim(User),uName)
self%User = trim(uName)

end subroutine getUser

!--------------------------------------------------------------------------
subroutine getfftwWisdomfilename(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the filename of the fftw wisdom file

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%fftwWisdomfilename = trim(self%Resourcepathname)//SC_fftwwisdomtxt

end subroutine getfftwWisdomfilename

!--------------------------------------------------------------------------
subroutine getwikicodefilename(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the wikicodefilename

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

self%wikicodefilename = trim(self%Resourcepathname)//SC_wikicodestxt

end subroutine getwikicodefilename

!--------------------------------------------------------------------------
subroutine getEMsoftHDFtest(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the EMsoftHDFtest environment variable 

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64

IMPLICIT NONE

class(EMsoft_T),intent(inout)      :: self

character(fnlen)                   :: envParam, envReturn

envParam = 'EMsoftHDFtest'
call getenv(trim(envParam),envReturn)
self%EMsoftHDFtest = 'No'
if (trim(envReturn).ne.'') then 
  self%EMsoftHDFtest = 'Yes'
end if 

end subroutine getEMsoftHDFtest

!--------------------------------------------------------------------------
function getJSONparameter(self, ep, nobackslash) result(param)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! returns the ep variable from the EMsoftconfig.json file

use json_module

use, intrinsic :: iso_fortran_env , only: error_unit, wp => real64
use mod_io 

IMPLICIT NONE

class(EMsoft_T),intent(inout)           :: self

character(fnlen),INTENT(IN)             :: ep
 !! JSON variable name string
logical,INTENT(IN),optional             :: nobackslash
 !! optionally, omit the backslash from the output string
character(fnlen)                        :: param
 !! subroutine return string

type(IO_T)                         :: Message
type(json_file)                         :: json
integer(kind=irg)                       :: error_cnt, slen
character(kind=jsonCK,len=:),allocatable:: cval
character(fnlen)                        :: jsonfilename, jsonname, mm(2)
logical                                 :: found, jexists, bs

Message = IO_T()

bs = .TRUE.
if (present(nobackslash)) then
  if (nobackslash.eqv..TRUE.) bs = .FALSE.
end if 

jsonfilename = SC_jsonfilename
jsonname =  trim(self%Configpath)//self%EMsoftnativedelimiter//trim(jsonfilename)

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

if (jexists) then
! initialize the json state variables
  error_cnt = 0
  call json_initialize()
  if (json_failed()) then
    call json_print_error_message(error_unit)
    stop
  end if

! and load the file
  call json%load_file(filename = trim(jsonname))
  if (json_failed().eqv..TRUE.) then    !if there was an error reading the file
    call json_print_error_message(error_unit)
    stop
  end if

  call json%get(trim(ep), cval, found)
  if (.not. found) then
   if (trim(ep).eq.SC_Develop) then
     param = trim(ep)
   else
     mm(1) = 'field '//trim(ep)//' not found in json file: '//trim(jsonname)
     mm(2) = 'continuing with empty parameter value for '//trim(ep) 
     call Message % printWarning('USER='//trim(self%User), mm)
     param = ''
   end if
  else
    param = trim(cval)
  end if

! and make sure there is a terminating EMsoftnativedeliter character, except when the 
! field has zero length, in which case some other default behavior will be assumed; this 
! last case was added on 08/15/17 to offer an alternative file location mechanism to the user, namely
! either a full path declaration or the current working folder, to complement the default
! behavior which is to prepend the contents of the datapathname configuration variable.
  slen = len(trim(cval))
  if ((slen.ne.0).and.(bs.eqv..TRUE.)) then 
    if (cval(slen:slen).ne.self%EMsoftnativedelimiter) then
      param = trim(cval)//self%EMsoftnativedelimiter
    end if
  end if
else
  if (displayConfigFileMissingMessage.eq.0) then 
    mm(1) = 'file '//trim(jsonname)//' not found '
    mm(2) = '  -----> Trying environment variables next ... '
    call Message % printWarning('  WARNING: USER='//trim(self%User), mm)
    displayConfigFileMissingMessage = 1
  end if
  param = 'tryEnvironmentVariable'
end if


end function getJSONparameter

!--------------------------------------------------------------------------
subroutine printEMsoftHeader(self, progname, progdesc, makeconfig)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! prints a copyright statement as well as where the user can find the license information
  !! This is then followed by the program name, a one-line description, and a time stamp.

use mod_io 
use mod_timing 

IMPLICIT NONE

class(EMsoft_T),intent(inout)         :: self
character(fnlen),INTENT(IN)           :: progname
 !! name of the calling program
character(fnlen),INTENT(IN)           :: progdesc
 !! description of what the calling program does
logical,INTENT(IN),OPTIONAL           :: makeconfig
 !! do we need to (optionally) generate the configuration file ?

type(IO_T)                       :: Message
type(Timing_T)                   :: Timing

 Message = IO_T() 

 call Message % printMessage('<EMsoftHeader>',frm="(/A/)")
 call Message % printMessage('Copyright (C) 2001-2020 Marc De Graef Research Group/CMU',frm="(A)")
 call Message % printMessage('EMsoft comes with ABSOLUTELY NO WARRANTY.')
 call Message % printMessage('This is free software, and you are welcome to redistribute it')
 call Message % printMessage('under certain conditions; see License.txt file for details.',frm="(A/)")

 call Message % printMessage('Program name         : '//trim(progname))
 call Message % printMessage('Purpose              : '//trim(progdesc))
 call Message % printMessage('Platform             : '//"@CMAKE_SYSTEM_NAME@")
 call Message % printMessage('Source code version  : '//trim(self % EMsoftversion))
 call Message % printMessage('Source code Revision : '//trim(self % EMsoftRevision))
 call Message % printMessage('Build Date/Time      : '//trim(self % EMsoftBuildDate),frm="(A/)")

 call Message % printMessage( 'See https://github.com/EMsoft-org/EMsoft/wiki for selected help pages.',frm="(A/)")

 Timing = Timing_T(showDateTime=.TRUE.)

 call Message % printMessage('</EMsoftHeader>',frm="(A/)")

 if (present(makeconfig)) then ! we need to (re-)create the EMsoftConfig.json file...
    if (makeconfig.eqv..TRUE.) then
      call self%path_init
    end if
 end if

end subroutine printEMsoftHeader

!--------------------------------------------------------------------------
function toNativePath(self, inpath) result(outpath)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! convert a path string from the native format to the other one

IMPLICIT NONE

class(EMsoft_T),intent(inout)    :: self

character(fnlen),INTENT(IN)           :: inpath
 !! path to be converted 
character(fnlen)                      :: outpath
 !! output path

integer(kind=irg)                     :: i, slen
character(1)                          :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
todelim = self%EMsoftnativedelimiter

if (todelim.eq.'\') then    ! ' 
  fromdelim = '/'
else
  fromdelim = '\'           ! '
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function toNativePath

!--------------------------------------------------------------------------
function fromNativePath(self, inpath) result(outpath)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! convert a path string to the native format on this platform

IMPLICIT NONE

class(EMsoft_T),intent(inout)        :: self

character(fnlen),INTENT(IN)          :: inpath
 !! input path to be converted
character(fnlen)                     :: outpath
 !! output path

integer(kind=irg)                    :: i, slen
character(1)                         :: todelim, fromdelim, c

slen = len(inpath)
outpath = ''
fromdelim = self%EMsoftnativedelimiter

if (fromdelim.eq.'/') then
  todelim = '\'      ! ' 
else
  todelim = '/'
end if

do i=1,slen
  c = inpath(i:i)
  if (c.eq.fromdelim) c = todelim
  outpath(i:i) = c
end do

end function fromNativePath

!--------------------------------------------------------------------------
subroutine path_init(self)
  !! author: MDG 
  !! version: 1.0 
  !! date: 12/31/19
  !!
  !! This routine is called at the start of every EMsoft program; first,
  !! we check to see whether or not the configuration file exists in .config/EMsoft.
  !! If it exists, we copy it to a different file name so that we can create a new one.
  !! If it does not exist, then we create it with some default parameters and ask the
  !! user for some others.
 
use mod_io

IMPLICIT NONE

class(EMsoft_T),intent(inout)           :: self

type(IO_T)                         :: Message 
character(fnlen)                        :: pathstring, dirstring, ep, EMsoftpathname, EMdatapathname, &
                                           username, userlocn, useremail, m
integer(kind=irg)                       :: i, error_cnt
logical                                 :: found, fexists, jexists
character(fnlen)                        :: confname, emsoftname, jsonname, jsonfilename, fname, cwd, &
                                           dirname, library, dataname, xtalname
character(3)                            :: release, develop
character(len=1)                        :: edp, tab, yesno 

edp = '"'
tab = CHAR(9)
yesno = 'n'
EMsoftpathname = ''
EMdatapathname = ''

! default names for the json configuration file
confname = SC_config
emsoftname = SC_EMsoft
jsonfilename = SC_jsonfilename

! get the config file name
jsonname = self % generateFilePath('Configpath',jsonfilename)

! test whether or not this file actually exists
inquire(file=trim(jsonname),exist=jexists)

! if this routine is called with config=.TRUE. parameter, then that means that we
! must create a new EMsoftConfig.json file if it doesn't already exist; we will inform
! the user if it does exist, and rename the existing file
Message = IO_T()

if (jexists) then
  call Message % printMessage( (/ '-------                                                                         ', &
                                  'WARNING: An older configuration file already exists in the .config/EMsoft folder', &
                                  '         The existing file will be renamed and a new file created.              '/) )
  call Message % ReadValue('          Do you want to continue ? (y/n) ', yesno, frm="(A1)" )
  if (yesno.eq.'n') then
    stop 'program terminated'
  end if
  call Message % printMessage('         Renaming old file to '//trim(jsonname)//'.save')
  call Message % printMessage((/ '         Creating new configuration file', &
                                 '-------                                 '/) )
  if (trim(self % EMsoftplatform).ne.'Windows') then   ! use the UNIX rename command 'mv oldname newname'
    call system('mv '//trim(jsonname)//' '//trim(jsonname)//'.save')
  else   ! on Windows the file rename command is 'ren oldname newname'
    call system('ren '//trim(jsonname)//' '//trim(jsonname)//'.save')
  end if
end if

! look for the .config/EMsoft/EMsoftConfig.json file one step at a time
dirstring = self % userHomepathname
call chdir(trim(dirstring))

! check for the .config folder
dirname = trim(dirstring)//self % EMsoftnativedelimiter//trim(confname)
inquire(file=trim(dirname),exist=fexists)
if (.not.(fexists)) then
  call system('mkdir '//trim(dirname))
  call Message % printMessage(trim(dirname)//' folder did not exist and has been created')
end if
call chdir(trim(dirname))

! check for the EMsoft folder
dirname = trim(dirname)//self % EMsoftnativedelimiter//SC_EMsoft
inquire(file=trim(dirname),exist=fexists)
if (.not.(fexists)) then
  call system('mkdir '//trim(dirname))
  call Message % printMessage(trim(dirname)//' folder did not exist and has been created')
end if
call chdir(trim(dirname))

! check whether or not the tmp folder exists...
fname = trim(dirname)//self % EMsoftnativedelimiter//SC_tmp
inquire(file=trim(fname),exist=fexists)
if (.not.(fexists)) then
  call system('mkdir '//trim(fname))
  call Message % printMessage(trim(fname)//' folder did not exist and has been created')
end if

! ok, so we have created the correct folder structure; now we need to generate the
! skeleton EMsoftConfig.json file, which then needs to be edited by the user

release = 'No'
develop = 'No'

! generate the json file; in principle we can replace all of these with Message class statements,
! but there's really no reason to do so ... 
open(unit=dataunit,file=trim(jsonname),status='new',form='formatted')
call Message % printMessage('{',redirect=dataunit)
write (dataunit,"(A,A,'EMsoftpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMXtalFolderpathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMdatapathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMtmppathname',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(fname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'EMsoftLibraryLocation',A,': ',A,A,A,',')") tab, edp, edp, edp, &
   trim(self%userHomepathname)//self % EMsoftnativedelimiter,edp
write (dataunit,"(A,A,'Release',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(release), edp
write (dataunit,"(A,A,'Develop',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(develop), edp

call Message % printMessage((/ '-------                                                                ', &
                               'Please respond to the following questions (each entry < 132 characters)'/) )
call Message % ReadValue('  Enter your user name : ', username, frm="(A)" )
write (dataunit,"(A,A,'UserName',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(username), edp

call Message % ReadValue('  Enter your email address : ', useremail, frm="(A)" )
write (dataunit,"(A,A,'UserEmail',A,': ',A,A,A,',')") tab, edp, edp, edp, trim(useremail), edp

call Message % ReadValue('  Enter your affiliation : ', userlocn, frm="(A)" )
write (dataunit,"(A,A,'UserLocation',A,': ',A,A,A)") tab, edp, edp, edp, trim(userlocn), edp

call Message % printMessage('}',redirect=dataunit)
close(unit=dataunit,status='keep')

call Message % printMessage( &
  (/'                                                                                                    ', &
    ' A skeleton EMsoftConfig.json file has been created in your .config/EMsoft folder.                  ', &
    ' You will need to edit this file to change the parameters from their default values.                ', &
    '                                                                                                    ', &
    ' - EMsoftpathname should point to the top folder of your EMsoft installation.                       ', &
    ' - EMdatapathname should point to where you want to keep all EMsoft output files.                   ', &
    '   Note that this folder should NOT be inside the EMsoftpathname folder!                            ', &
    '   You may leave this variable undefined (empty string) to force programs to                        ', &
    '   generate all files in the current working folder or to use full path file names.                 ', &
    ' - EMXtalFolderpathname should point to the folder that will contain the *.xtal files.              ', &
    ' - EMtmppathname should point to the tmp folder where the EMsoftConfig.json file is located.        ', &
    ' - EMsoftLibraryLocation is needed only if you have a fully subroutineal IDL installation; this     ', &
    '   variable should then point to the location of the EMsoftLib.dylib or EMsoftLib.dll file.         ', &
    ' - One of the variables Develop and Release should be set to Yes, the other to No; if you are       ', &
    '   developing new EMsoft code using the EMsoftPrivate folder, then set Develop to Yes               ', &
    '   and Release to No to indicate Debug mode. for regular users: Develop=No, Release=Yes             ', &
    ' - EMNotify can be set to Slack or Email to send program completion messages to the user            ', &
    ' - EMSlackWebHookURL and EMSlackChannel are used for Slack messages (see Package Configuration wiki)', &
    '                                                                                                    ', &
    ' Make sure that each non-empty pathname ends with /, even on Windows platforms !                    ', &
    '                                                                                                    ', &
    ' Every EMsoft program will read this configuration file to figure out where things are located.     '/) )

end subroutine path_init


end module mod_EMsoft
