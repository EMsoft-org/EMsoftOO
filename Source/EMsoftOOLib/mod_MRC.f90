! ###################################################################
! Copyright (c) 2013-2020, Marc De Graef Research Group/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are 
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list 
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this 
!        list of conditions and the following disclaimer in the documentation and/or 
!        other materials provided with the distribution.
!     - The name of Marc De Graef may not be used to endorse or promote products 
!	derived from this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################

module mod_MRC
  !! author: MDG 
  !! version: 1.0 
  !! date: 02/05/20
  !!
  !! general class routines for .mrc formatted IO, originally written as part of MCAP project
  !! with AFRL/UES C-875-170-001 (2013).
  !!
  !! This was taken from http://www.biochem.mpg.de/doc_tom/index.html using the
  !! tom_mrcfeistack2emseries code, as well as  http://bio3d.colorado.edu/imod/doc/mrc_format.txt
  !! We are going to assume an IMOD version of 2.6.20 or better.
  !!
  !! Routines were tested against IDL version of MRC reader; a file generated by this program can
  !! be read successfully by the IDL code.  The files created by this module should be readable 
  !! by such programs as IMOD, FIJI and CHIMERA
  !!----------------------------------------------------------------
  !!----------------------------------------------------------------
  !!----------------------------------------------------------------
  !! here is how to save a data volume to an mrc file:
  !!
  !! ! in the declaration section your routine add the following lines:
  !!
  !! use mod_MRC
  !!
  !! type(MRC_T)                :: MRC
  !! type(MRCstruct)            :: MRCheader
  !! type(FEIstruct)            :: FEIheaders(1024)
  !! real(kind=dbl),allocatable :: psum(:)
  !! real(kind=dbl),allocatable :: volume(:,:,:)      ! you'll need to fill this array with values ... 
  !! integer(kind=irg)          :: numx, numy, numz   ! set these to the size of the volume array
  !! character(fnlen)           :: mrcname            ! and this is the output filename
  !! 
  !! !----------------------------------------------------------------
  !! ! open the MRC output file
  !! mrcname = '/full/path/to/mrc/file.mrc' 
  !! MRC = MRC_T( mrcname )
  !! 
  !! !----------------------------------------------------------------
  !! ! we assume that the data is called "volume" and has dimensions numx x numy x numz
  !! call MRC%setVolumeDimensions( (/ numx, numy, numz /) )
  !!
  !! !----------------------------------------------------------------
  !! ! define the relevant entries in the MRCheader structure (other entries are not important and 
  !! ! will be set to their default values)
  !! MRCheader%nx = numx
  !! MRCheader%ny = numy
  !! MRCheader%nz = numz
  !! MRCheader%mode = 2    ! for floating point output
  !! MRCheader%mx = numx
  !! MRCheader%my = numy
  !! MRCheader%mz = numz
  !! MRCheader%amin = minval(volume)
  !! MRCheader%amax = maxval(volume)
  !! MRCheader%amean = sum(volume)/float(numx)/float(numy)/float(numz)
  !! MRCheader%xlen = numx
  !! MRCheader%ylen = numy
  !! MRCheader%zlen = numz
  !!
  !! ! and set the header
  !! MRC%setMRCheader(MRCheader)
  !! 
  !! !----------------------------------------------------------------
  !! ! fill the relevant entries in the FEIheaders; none of these values are 
  !! ! actually used, except for mean_int
  !! allocate(psum(numz))
  !! psum = sum(sum(volume,1),1)
  !! do i=1,numz
  !!   FEIheaders(i)%b_tilt = 0.0
  !!   FEIheaders(i)%defocus = 0.0
  !!   FEIheaders(i)%pixelsize = 1.0e-9
  !!   FEIheaders(i)%magnification = 1000.0
  !!   FEIheaders(i)%voltage = 0.0
  !!   FEIheaders(i)%mean_int = psum(i)/float(numx)/float(numy)
  !! end do
  !!
  !! ! and set the headers
  !! MRC%setFEIheaders(FEIheaders)
  !! 
  !! !----------------------------------------------------------------
  !! ! and finally write the file; 
  !! call MRC%write_3Dvolume(volume,verbose=.TRUE.) ! last parameter is optional
 
use mod_kinds
use mod_global

IMPLICIT NONE

private 

! type definitions for mrc file format writing
type,public :: FEIstruct
    real(kind=sgl)          :: a_tilt = 0.0
    real(kind=sgl)          :: b_tilt = 0.0
    real(kind=sgl)          :: x_stage = 0.0
    real(kind=sgl)          :: y_stage = 0.0
    real(kind=sgl)          :: z_stage = 0.0
    real(kind=sgl)          :: x_shift = 0.0
    real(kind=sgl)          :: y_shift = 0.0
    real(kind=sgl)          :: defocus = 0.0
    real(kind=sgl)          :: exp_time = 0.0
    real(kind=sgl)          :: mean_int = 0.0
    real(kind=sgl)          :: tiltaxis = 0.0
    real(kind=sgl)          :: pixelsize = 0.0
    real(kind=sgl)          :: magnification = 0.0
    real(kind=sgl)          :: voltage = 0.0
    character(72)           :: unused
end type FEIstruct

type, public :: MRCstruct
    integer(kind=irg)       :: nx = 0 ! number of columns
    integer(kind=irg)       :: ny = 0 ! number of rows
    integer(kind=irg)       :: nz = 0 ! number of sections
    integer(kind=irg)       :: mode = 1 ! type of image pixel 
    integer(kind=irg)       :: nxstart = 0 ! starting point of subimage
    integer(kind=irg)       :: nystart = 0 !  
    integer(kind=irg)       :: nzstart = 0 ! 
    integer(kind=irg)       :: mx = 0 ! grid size in x
    integer(kind=irg)       :: my = 0 ! grid size in y
    integer(kind=irg)       :: mz = 0 ! grid size in z
    real(kind=sgl)          :: xlen = 0 ! cell size; pixel spacing = xlen/mx, ylen/my, zlen/mz
    real(kind=sgl)          :: ylen = 0 !
    real(kind=sgl)          :: zlen = 0 !
    real(kind=sgl)          :: alpha = 90.0 ! cell angles - ignored by IMOD
    real(kind=sgl)          :: beta =90.0 !
    real(kind=sgl)          :: gamma = 90.0 !
    integer(kind=irg)       :: mapc = 1 ! map column  1=x,2=y,3=z
    integer(kind=irg)       :: mapr = 2 ! map row     1=x,2=y,3=z
    integer(kind=irg)       :: maps =3 ! map section 1=x,2=y,3=z
    real(kind=sgl)          :: amin = 0.0 ! minimum pixel value (needs to be set for proper scaling of data)
    real(kind=sgl)          :: amax = 0.0 ! maximum pixel value
    real(kind=sgl)          :: amean = 0.0 ! mean pixel value
    integer(kind=ish)       :: ispg = 0 ! space group number
    integer(kind=ish)       :: nsymbt = 0 ! NOT SURE WHAT THIS IS
    integer(kind=irg)       :: next = 131072 ! number of bytes in extended header (1024 * 128 for FEI)
    integer(kind=ish)       :: creatid = 0 ! used to be an ID number, is 0 as of IMOD 4.2.23
    character(30)           :: extra_data = '00                            ' ! string(' ',format='(A30)'), not used, first two bytes should be 0
    integer(kind=ish)       :: numint = 0 ! number of bytes per section (SerialEM interpretation) [renamed from nint to numin]
    integer(kind=ish)       :: nreal = 32 ! bit flags for short data type
    character(20)           :: extra_data_2= '                    ' ! string(' ',format='(A20)'), $ ; not used
    integer(kind=irg)       :: imodStamp = 0 ! 
    integer(kind=irg)       :: imodFlags = 0 !
    integer(kind=ish)       :: idtype = 0 !  ( 0 = mono, 1 = tilt, 2 = tilts, 3 = lina, 4 = lins)
    integer(kind=ish)       :: lens = 0 !
    integer(kind=ish)       :: nd1 = 0 ! for idtype = 1, nd1 = axis (1, 2, or 3)
    integer(kind=ish)       :: nd2 = 0 ! 
    integer(kind=ish)       :: vd1 = 0 ! vd1 = 100. * tilt increment
    integer(kind=ish)       :: vd2 = 0 ! vd2 = 100. * starting angle
    real(kind=sgl)          :: tiltangles(6) !  0,1,2 = original:  3,4,5 = current
    real(kind=sgl)          :: xorg = 0.0 ! origin of image
    real(kind=sgl)          :: yorg = 0.0 !
    real(kind=sgl)          :: zorg = 0.0 !
    character(4)            :: cmap = 'MAP '
    character(4)            :: stamp = 'DA  ' ! First two bytes have 17 and 17 for big-endian or 68 and 65 for little-endian
    real(kind=sgl)          :: rms = 0.0 ! RMS deviation of densities from mean density
    integer(kind=irg)       :: nlabels =0 ! Number of labels with useful data
    character(800)          :: labels ! string(' ',format='(A800)') $ ; 10 labels of 80 characters each
end type MRCstruct

type, public :: MRC_T 
  private
    type(MRCstruct)         :: MRCheader 
    type(FEIstruct)         :: FEIheaders(1024)
    integer(kind=irg)       :: RecLength = 256  ! direct access record length
    character(len=256)      :: Rekord           ! this is a sort of output buffer
    integer(kind=irg)       :: Rec_No=0, L=0    ! record parameters
    integer(kind=irg)       :: Unit_No=64       ! output unit number
    character(fnlen)        :: mrcname 
    integer(kind=irg)       :: numx, numy, numz

  contains
  private

    procedure, pass(self) :: write_3Dvolume_
    procedure, pass(self) :: write_MRCheader
    procedure, pass(self) :: write_FEIheaders
    procedure, pass(self) :: Write_Real
    procedure, pass(self) :: Write_Word
    procedure, pass(self) :: Write_Short
    procedure, pass(self) :: Write_String
    procedure, pass(self) :: Write_Byte_Into_Buffer
    procedure, pass(self) :: setVolumeDimensions_
    procedure, pass(self) :: setMRCheader_
    procedure, pass(self) :: setFEIheaders_

    generic, public :: write_3Dvolume => write_3Dvolume_
    generic, public :: setVolumeDimensions => setVolumeDimensions_
    generic, public :: setMRCheader => setMRCheader_ 
    generic, public :: setFEIheaders => setFEIheaders_ 

end type MRC_T 
!DEC$ ATTRIBUTES DLLEXPORT :: write_3Dvolume
!DEC$ ATTRIBUTES DLLEXPORT :: setVolumeDimensions
!DEC$ ATTRIBUTES DLLEXPORT :: setMRCheader
!DEC$ ATTRIBUTES DLLEXPORT :: setFEIheaders

! the constructor routine for this class 
interface MRC_T
  module procedure MRC_constructor
end interface MRC_T

contains

!--------------------------------------------------------------------------
type(MRC_T) function MRC_constructor( mrcname ) result(MRC)
!! author: MDG 
!! version: 1.0 
!! date: 02/04/20
!!
!! constructor for the MRC_T Class
 
IMPLICIT NONE

character(fnlen)  :: mrcname 

character(34)     :: s = 'mrc file created by EMsoft library'
integer(kind=irg) :: slen, j

! set the file name
MRC%mrcname = trim(mrcname)

! first set a label to indicate the origin of this file
MRC % MRCheader % nlabels = 1
slen = 34
do j=1,slen
  MRC % MRCheader % labels(j:j) = s(j:j) 
end do

MRC%Rec_No = 0
MRC%L = 0

! and open the file
open(UNIT=MRC%Unit_No,file=trim(MRC%mrcname),access="DIRECT",action="WRITE", &
     STATUS='unknown',FORM="UNFORMATTED", RECL=MRC%RecLength)

end function MRC_constructor

!--------------------------------------------------------------------------
recursive subroutine setVolumeDimensions_(self, dims )

IMPLICIT NONE 

class(MRC_T),INTENT(INOUT)        :: self 
integer(kind=irg), INTENT(INOUT)  :: dims(3)

self%numx = dims(1)
self%numy = dims(2)
self%numz = dims(3)

end subroutine setVolumeDimensions_ 

!--------------------------------------------------------------------------
recursive subroutine setMRCheader_(self, MRCheader )

IMPLICIT NONE 

class(MRC_T),INTENT(INOUT)        :: self 
type(MRCstruct), INTENT(INOUT)    :: MRCheader 

self%MRCheader = MRCheader 

end subroutine setMRCheader_ 

!--------------------------------------------------------------------------
recursive subroutine setFEIheaders_(self, FEIheaders )

IMPLICIT NONE 

class(MRC_T),INTENT(INOUT)        :: self 
type(FEIstruct), INTENT(INOUT)    :: FEIheaders(1024)

self%FEIheaders = FEIheaders 

end subroutine setFEIheaders_ 

!--------------------------------------------------------------------------
recursive subroutine write_3Dvolume_(self, volume, verbose)
!! author: MDG 
!! version: 1.0 
!! date: 02/04/20
!!
!! creates a .mrc file and writes the volume (i.e., data volume) to it

use mod_io

IMPLICIT NONE

class(MRC_T),INTENT(INOUT)    :: self 
real(kind=dbl),INTENT(IN)     :: volume(self%numx, self%numy, self%numz)
logical,INTENT(IN),optional   :: verbose

type(IO_T)                    :: Message
integer(kind=irg)             :: slen, j, ix ,iy, ith
logical                       :: v

v = .FALSE.
if (PRESENT(verbose)) then 
  if (verbose.eqv..TRUE.) v = .TRUE.
end if
 
! first we need to write the headers
if (v.eqv..TRUE.) call Message%printMessage('Writing headers to file '//trim(self%mrcname))

call self%write_MRCheader()
call self%write_FEIheaders()

! next, write the volume
if (v.eqv..TRUE.) call Message%printMessage('Writing volume data to file '//trim(self%mrcname))
do ith = 1, self%numz
  do iy = 1, self%numy
    do ix = 1, self%numx
      call self%Write_Real(sngl(volume(ix,iy,ith)),4)
    end do
  end do
end do

! make sure the last record is actually written to the file
self%L=len(self%Rekord)
call self%Write_Byte_Into_Buffer(char(0))
 
! close and save file
 close(unit=self%Unit_No, status="KEEP")
 if (v.eqv..TRUE.) call Message%printMessage('Writing volume data to file '//trim(self%mrcname))

end subroutine write_3Dvolume_

!--------------------------------------------------------------------------
subroutine write_MRCheader(self)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write the MRC header to the file

IMPLICIT NONE

class(MRC_T), INTENT(INOUT)  :: self 

integer(kind=irg)			       :: i

! this is a simple direct dump of all the structure entries into the MRC buffer
 call self%Write_Word(self%MRCheader%nx,4)
 call self%Write_Word(self%MRCheader%ny,4)
 call self%Write_Word(self%MRCheader%nz,4)
 call self%Write_Word(self%MRCheader%mode,4)
 call self%Write_Word(self%MRCheader%nxstart,4)
 call self%Write_Word(self%MRCheader%nystart,4)
 call self%Write_Word(self%MRCheader%nzstart,4)
 call self%Write_Word(self%MRCheader%mx,4)
 call self%Write_Word(self%MRCheader%my,4)
 call self%Write_Word(self%MRCheader%mz,4)
 call self%Write_Real(self%MRCheader%xlen,4)
 call self%Write_Real(self%MRCheader%ylen,4)
 call self%Write_Real(self%MRCheader%zlen,4)
 call self%Write_Real(self%MRCheader%alpha,4)
 call self%Write_Real(self%MRCheader%beta,4)
 call self%Write_Real(self%MRCheader%gamma,4)
 call self%Write_Word(self%MRCheader%mapc,4)
 call self%Write_Word(self%MRCheader%mapr,4)
 call self%Write_Word(self%MRCheader%maps,4)
 call self%Write_Real(self%MRCheader%amin,4)
 call self%Write_Real(self%MRCheader%amax,4)
 call self%Write_Real(self%MRCheader%amean,4)
 call self%Write_Short(self%MRCheader%ispg,2)
 call self%Write_Short(self%MRCheader%nsymbt,2)
 call self%Write_Word(self%MRCheader%next,4)
 call self%Write_Short(self%MRCheader%creatid,2)
 call self%Write_String(self%MRCheader%extra_data,30)
 call self%Write_Short(self%MRCheader%numint,2)   ! remember that this entry was renamed from nint
 call self%Write_Short(self%MRCheader%nreal,2)
 call self%Write_String(self%MRCheader%extra_data_2,20)
 call self%Write_Word(self%MRCheader%imodStamp,4)
 call self%Write_Word(self%MRCheader%imodFlags,4)
 call self%Write_Short(self%MRCheader%idtype,2)
 call self%Write_Short(self%MRCheader%lens,2)
 call self%Write_Short(self%MRCheader%nd1,2)
 call self%Write_Short(self%MRCheader%nd2,2)
 call self%Write_Short(self%MRCheader%vd1,2)
 call self%Write_Short(self%MRCheader%vd2,2)
 do i=1,6
   call self%Write_Real(self%MRCheader%tiltangles(i),4)
 end do
 call self%Write_Real(self%MRCheader%xorg,4)
 call self%Write_Real(self%MRCheader%yorg,4)
 call self%Write_Real(self%MRCheader%zorg,4)
 call self%Write_String(self%MRCheader%cmap,4)
 call self%Write_String(self%MRCheader%stamp,4)
 call self%Write_Real(self%MRCheader%rms,4)
 call self%Write_Word(self%MRCheader%nlabels,4)
 call self%Write_String(self%MRCheader%labels,800)

end subroutine write_MRCheader

!--------------------------------------------------------------------------
subroutine write_FEIheaders(self)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write the FEIheaders to the file

IMPLICIT NONE

class(MRC_T), INTENT(INOUT)  :: self

integer(kind=irg)			       :: i

do i=1,1024
 call self%Write_Real(self%FEIheaders(i)%a_tilt,4)
 call self%Write_Real(self%FEIheaders(i)%b_tilt,4)
 call self%Write_Real(self%FEIheaders(i)%x_stage,4)
 call self%Write_Real(self%FEIheaders(i)%y_stage,4)
 call self%Write_Real(self%FEIheaders(i)%z_stage,4)
 call self%Write_Real(self%FEIheaders(i)%x_shift,4)
 call self%Write_Real(self%FEIheaders(i)%y_shift,4)
 call self%Write_Real(self%FEIheaders(i)%defocus,4)
 call self%Write_Real(self%FEIheaders(i)%exp_time,4)
 call self%Write_Real(self%FEIheaders(i)%mean_int,4)
 call self%Write_Real(self%FEIheaders(i)%tiltaxis,4)
 call self%Write_Real(self%FEIheaders(i)%pixelsize,4)
 call self%Write_Real(self%FEIheaders(i)%magnification,4)
 call self%Write_Real(self%FEIheaders(i)%voltage,4)
 call self%Write_String(self%FEIheaders(i)%unused,72)
end do

end subroutine write_FEIheaders

!--------------------------------------------------------------------------
subroutine Write_Byte_Into_Buffer(self, Bite)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write a single byte into a buffer and dump the buffer to file if full

IMPLICIT NONE

class(MRC_T),INTENT(INOUT)    :: self
character(len=1),intent(IN)   :: Bite  
 !! byte variable

! increment byte counter
 self%L=self%L+1
 
! is record full ?
 if (self%L>len(self%Rekord)) then  ! yes it is, so write to file
  self%Rec_No = self%Rec_No + 1
  write (unit=self%Unit_No,REC=self%Rec_No) self%Rekord
! reset entire record to zero
  self%Rekord(1:len(self%Rekord))=char(0)
  self%L = 1
 end if

! add byte to record
 self%Rekord(self%L:self%L) = Bite

end subroutine Write_Byte_Into_Buffer

!--------------------------------------------------------------------------
subroutine Write_Word(self, Word, Length)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write a 4-byte word into the buffer

IMPLICIT NONE

class(MRC_T),INTENT(INOUT)      :: self
integer(kind=irg),intent(IN)    :: Word   !< 4-byte word
integer(kind=irg),intent(IN)    :: Length !< length parameter

integer(kind=irg)               :: L_Word
integer(kind=irg)               :: j
character(len=1)                :: Ch

 L_Word = Word
 do j=1,Length
  Ch = char(iand(L_Word,255))
  call self%Write_Byte_Into_Buffer(Ch)
  L_Word = ishft(L_Word,-8)
 end do
 
end subroutine Write_Word

!--------------------------------------------------------------------------
subroutine Write_Short(self, Word, Length)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write a 2-byte integer into the buffer

IMPLICIT NONE

class(MRC_T),INTENT(INOUT)      :: self
integer(kind=ish),INTENT(IN)    :: Word   !< 2 byte integer
integer(kind=irg),intent(IN)    :: Length !< length parameter

integer(kind=irg)               :: L_Word
integer(kind=irg)               :: j
character(len=1)                :: Ch

 L_Word = Word
 do j=1,Length
  Ch = char(iand(L_Word,255))
  call self%Write_Byte_Into_Buffer(Ch)
  L_Word = ishft(L_Word,-8)
 end do
 
end subroutine Write_Short

!--------------------------------------------------------------------------
!
! SUBROUTINE:MRC_Write_Real
!
!> @author R.A. Vowels /Marc De Graef, Carnegie Melon University
!
!> @brief write a 4-byte real into the buffer
!
!> @param RWord 4-byte real
!> @param Length length parameter
!! 
!> @date    ?/??/96 RAV 1.0 original
!> @date    4/17/13 MDG 2.0 commented and change of variable names
!--------------------------------------------------------------------------
subroutine Write_Real(self, RWord, Length)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write a 4-byte real into the buffer

IMPLICIT NONE

class(MRC_T),INTENT(INOUT)      :: self
real(kind=sgl),INTENT(IN)       :: RWord  !< 4 byte real
integer(kind=irg),intent(IN)    :: Length !< length parameter

integer(kind=irg)               :: L_Word
integer(kind=irg)               :: j
character(len=1)                :: Ch

 L_Word = transfer(RWord,0)
 do j=1,Length
  Ch = char(iand(L_Word,255))
  call self%Write_Byte_Into_Buffer(Ch)
  L_Word = ishft(L_Word,-8)
 end do
 
end subroutine Write_Real

!--------------------------------------------------------------------------
subroutine Write_String(self, Str, Length)
 !! author: MDG 
 !! version: 1.0 
 !! date: 02/04/20
 !!
 !! write a series of characters into the buffer

IMPLICIT NONE

class(MRC_T),INTENT(INOUT)      :: self
character(*),intent(IN)         :: Str      !< input string
integer(kind=irg),intent(IN)    :: Length   !< length parameter

integer(kind=irg)               :: j

 do j=1,Length
  call self%Write_Byte_Into_Buffer(Str(j:j))
 end do
 
end subroutine Write_String

end module mod_MRC
